# this에 대해 설명해 주세요.
- this는 '자신이 속한 객체를 가리키는 변수'.  

자바스크립트에서 함수 호출 방식에 의해 this에 바인딩할 객체가 동적으로 결정되는데,
함수를 호출할 때 함수가 어떻게 호출되었는지에 따라 this에 바인딩할 객체가 동적으로 결정된다

우선순위 
1. 생성자 함수 호출
2. apply/call/bind 호출
3. 메소드 호출
4. 함수 호출

## 1.	함수호출
**함수호출**은 기본적으로 this는 전역객체(Global object)에 바인딩된다. 전역함수뿐만아니라 내부함수의 경우에도 this는 외부함수가 아닌 전역객체에 바인딩된다.
그래서 전역객체를 피하려면바인딩을 명시적으로 보여줘야한다  apply, call, bind 메소드도 해당한다. 

## 2.	**메소드 호출** 
함수가 객체의 프로퍼티 값이면 메소드로서 호출된다. 이때 메소드 내부의 this는 해당 메소드를 소유한 객체,  해당 메소드를 호출한 객체에 바인딩된다. 

프로토타입 객체도 메소드를 가질 수 있다. 프로토타입 객체 메소드 내부에서 사용된 this도 일반 메소드 방식과 마찬가지로 해당 메소드를 호출한 객체에 바인딩된다.

## 3.	생성자 함수 호출
new 연산자와 함께 생성자 함수를 호출하면 this 바인딩이 메소드나 함수 호출 때와는 다르게 동작한다.

new 연산자와 생성자 함수를 호출하면 빈객체를 생성하고 이 객체에 this 바인딩한다.


빈객체는 생성자함수의 prototype 프로퍼티가 가르키는 객체를 자신의 프로토타입 객체로 설정한다.
빈 객체에 this를 이용해 프로퍼티, 메소드를 생성해 추가한다.
객체를 반환한다.
** this외에 다른것을 반환하거나 this를 반환하지 않는 함수는 생성자 함수의 역할을 수행할 수 없다는 것을 알 수 있다.

**생성자 함수 동작 방식**
  1) 빈 객체 생성 및 this 바인딩
- 생성자 함수의 코드가 실행되기 전 빈 객체가 생성된다. 이 빈 객체가 생성자 함수가 새로 생성하는 객체이다. 이후 생성자 함수 내에서 사용되는 this는 이 빈 객체를 가리킨다. 그리고 생성된 빈 객체는 생성자 함수의 prototype 프로퍼티가 가리키는 객체를 자신의 프로토타입 객체로 설정한다.

 2) this를 통한 프로퍼티 생성
- 생성된 빈 객체에 this를 사용하여 동적으로 프로퍼티나 메소드를 생성할 수 있다. this는 새로 생성된 객체를 가리키므로 this를 통해 생성한 프로퍼티와 메소드는 새로 생성된 객체에 추가된다.

 3) 생성된 객체 반환
- 반환문이 없는 경우, this에 바인딩된 새로 생성한 객체가 반환된다. 명시적으로 this를 반환하여도 결과는 같다.
- 반환문이 this가 아닌 다른 객체를 명시적으로 반환하는 경우, this가 아닌 해당 객체가 반환된다. 이때 this를 반환하지 않은 함수는 생성자 함수로서의 역할을 수행하지 못한다. 따라서 생성자 함수는 반환문을 명시적으로 사용하지 않는다.

## 4. apply/call/bind 명시적 호출
this에 바인딩될 객체는 함수 호출 패턴에 의해 결정된다.
자바스크립트 엔진의 암묵적 this 바인딩 이외에 this를 특정 객체에 명시적으로 바인딩하는 방법도 제공된다

## apply() 메소드를 호출하는 주체는 함수이며 apply() 메소드는 this를 특정 객체에 바인딩할 뿐 본질적인 기능은 함수 호출

apply() 메소드의 대표적인 용도는 arguments 객체와 같은 유사 배열 객체에 배열 메소드를 사용하는 경우

apply/call메소드는 호출할 함수에 인수를 전달하는 방식만 다를뿐 본질적으로 this로 사용할 객체를 전달하면서 함수를 호출하는 것은 동일하다.

Apply는 호출할 함수의 인수를 배열로 묶어 전달  

Call은 호출할 함수의 인수를 쉼표로 구분한 리스트 형식으로 전달합니다.

## call() 메소드의 경우, apply()와 기능은 같지만 apply()의 두번째 인자에서 배열 형태로 넘긴 것을 각각 하나의 인자로 넘긴다.   

## bind 함수는 함수가 가리키는 this만 바꾸고 호출하지는 않는 겁니다.정확히 말하면 this를 정의하고 나서 그 함수를 복사해 새로운 함수를 만들어 리턴 

Function.prototype.bind는 함수에 인자로 전달한 this가 바인딩된 새로운 함수를 리턴한다. 즉, Function.prototype.bind는 Function.prototype.apply, Function.prototype.call 메소드와 같이 함수를 실행하지 않기 때문에 명시적으로 함수를 호출할 필요가 있다.



```ts
var func = function () {
    return this;
};

var obj = {
  v: 3,
  o: {
    v: 5,
    m: func,
  },
  m1: () => func(),
  m2: () => this,
};

var result = 0;
result += func() == obj.o.m()  ? 1 : 0; //앞에껀 일반함수 호출(글로벌) 뒤에껀  메소드 호출한 객체 o가 호출 
result += obj.v == obj.o.m().v ? 1 : 0;//앞에껀 3  뒤에껀 5
result += obj.m2() == obj ? 1 : 0;//앞에껀 화살표함수라서 this가 없다 상위 스코프 호출 윈도우  뒤에껀 obj
result += func.bind(obj.o).call(obj) == func() ? 1 : 0;//앞에껀 func의 this로 obj.o를 바인딩후 call을 obj를 함 그렇지만 앞에 this가 obj.o로 고정되서 this가 obj.o 고정됨.   뒤에껀 func()

console.log(result);
```

https://poiemaweb.com/js-this

https://velog.io/@proshy/JS-%EC%83%81%ED%99%A9%EC%97%90-%EB%94%B0%EB%A5%B8-this-%EB%B0%94%EC%9D%B8%EB%94%A9
