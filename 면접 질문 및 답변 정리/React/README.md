# React

## 리액트를 사용해야하는 이유
### 1.react는 컴퍼넌트 기반의 UI 라이브러리

- Component: React에서 서비스를 개발하는 데 있어 독립적인 단위로 쪼개어 구현

### 2.React는 선언형 프로그래밍.(그냥 목적을 바로 말함)

- 목표결과를 기술하는방식

### 3.Virtual DOM

- 가상적인 표현을 메모리에 저장하고 ReactDOM과 같은 라이브러리에 의해 실제 DOM과 동기화하는 프로그래밍 개념

### Create React App

- Webpack: 다수의 자바스크립트 파일을 하나의 파일로 합쳐주는 모듈 번들 라이브러리
- babel:jsx 등의 쉽고 직관적인 자바스크립트 문법을 사용할 수 있도록 해주는 라이브러리

### JSX

- JavaScript 내에서 UI를 작성하기 위해 개발자에게 익숙한 환경을 제공, HTML과 유사함
- JSX를 활용하여 HTML 내에 필요한 데이터를 한 공간에 삽입할 수 있어 개발이 간단해지고 다른 사람이 개발 의도를 파악하기 쉬워집니다

생산성/재사용성

- Component와 Hook을 활용,작은 단위의, 독립적인 요소로 개발하여 개발자의 생산성과 코드의 재사용성을 높입니다.

풍부한 자료/라이브러리

- 현재 React는 전 세계적으로 가장 활발하게 커뮤니티 활동이 이뤄지고 있어 방대한 자료와 편리한 오픈소스 라이브러리 등이 공유되고 있습니다.

다양한 사용처

- 단순한 웹 애플리케이션뿐만 아니라 한 번 배운 React 지식을 React-Native에 적용하여 안드로이드 애플리케이션 및 iOS 애플리케이션등을 개발할 수 있습니다

State~계속해서 변화하는 특정상태

상태에따라 각각 다른 동작을 함.
### setState를 사용하는 이유
-React에서 상태(state)를 변경하고 다시 렌더링하는 것은 매우 중요한 기능이다. setState() 메소드를 사용하여 상태를 변경하는 것은 React의 핵심.
React에서 state는 컴포넌트의 데이터를 나타내는 것인데, 이 데이터는 동적으로 변경될 수 있다. 

-예를 들어, 사용자가 버튼을 클릭하면 상태가 변경이 가능한데, 이러한 상황에서 setState()를 사용하여 상태를 변경하면 React는 변경된 상태를 감지하고, 
해당 컴포넌트의 렌더링을 다시 실행하여 변경된 데이터를 화면에 업데이트한다.

-setState()는 두 가지 인수를 취한다. 첫 번째 인수는 새로운 상태를 나타내는 객체이고, 두 번째 인수는 상태 업데이트가 완료되면 호출될 콜백 함수이다. 상태 업데이트는 비동기적으로 처리될 수 있으므로, 콜백 함수를 사용하여 업데이트가 완료된 후 추가 작업을 수행할 수 있습니다.

-따라서 setState()를 사용하여 React 컴포넌트의 상태를 변경하면, React는 변경된 상태를 감지하여 컴포넌트를 다시 렌더링하고, 업데이트된 상태를 화면에 반영한다. 이를 통해 React는 동적인 UI를 생성하고 관리할 수 있다.


- 상태를 직접 변경하는 것이 좋지 않은 이유는 무엇인가요?
- React가 상태를 변경한 후 라이프사이클 메소드를 호출하는데, 라이프사이클 메소드에는 어떤 종류가 있나요?
- setState 함수를 호출하면 어떤 일이 일어나는 건가요? 동작 과정을 설명해주세요.


### props와 state의 차이
React에서 props와 state는 둘 다 컴포넌트에서 데이터를 다루는 방법입니다. 그러나 props와 state는 다음과 같은 차이점이 있습니다.

1.	변경 가능성: props는 컴포넌트 외부에서 전달되며, 읽기 전용입니다. 즉, props는 부모 컴포넌트에서 전달된 값을 변경할 수 없습니다. 반면, state는 컴포넌트 내부에서 선언되며, 컴포넌트 내에서 변경될 수 있습니다.

2.	영향 범위: props는 컴포넌트 간에 데이터를 전달하는 데 사용됩니다. 즉, 하위 컴포넌트로 전달되어 사용될 수 있습니다. 반면, state는 컴포넌트 내부에서만 사용됩니다.

3.	업데이트 방법: props는 상위 컴포넌트에서 전달되므로, 상위 컴포넌트에서 props를 업데이트하면 하위 컴포넌트에도 업데이트가 반영됩니다. 반면, state는 컴포넌트 내부에서만 업데이트가 가능하며, 상위 컴포넌트에서 state를 직접 업데이트할 수 없습니다.

4.	초기화: props는 컴포넌트가 생성될 때 전달됩니다. 반면, state는 컴포넌트가 생성될 때 기본값으로 초기화됩니다.

5.	데이터 종류: props는 주로 컴포넌트 간에 데이터를 전달하는 데 사용됩니다. 반면, state는 주로 컴포넌트 내에서 관리하는 데이터를 의미합니다.
요약하자면, props와 state는 React에서 데이터를 다루는 두 가지 방법입니다. props는 컴포넌트 간에 데이터를 전달하는 데 사용되며, 읽기 전용입니다. 반면, state는 컴포넌트 내부에서 관리되며, 컴포넌트 내에서 변경할 수 있습니다.


### React의 장점
1.	가상 DOM: React는 가상 DOM을 사용하여 성능을 최적화한다. 이는 브라우저에서 실제 DOM 업데이트를 최소화하고, 컴포넌트의 상태가 변경될 때마다 변경 사항을 최소화하여 렌더링을 최적화.
2.	재사용 가능한 컴포넌트: React는 재사용 가능한 컴포넌트를 작성하는 데 중점을 둔다. 이는 코드 재사용성을 높이고, 작업을 단순화하며, 유지보수를 용이하게 만든다.
3. 단방향 데이터 흐름: React는 단방향 데이터 흐름을 따르는데, 이 것은 데이터가 컴포넌트 계층 구조에서 위에서 아래로만 흐르기 때문에 언제 어디서 데이터가 변경되는지 쉽게 추적할 수 있으며, 예측 가능한 애플리케이션을 만들 수 있다.
4.	JSX: React는 JSX라는 자바스크립트와 HTML을 결합한 문법을 사용. 컴포넌트를 만들고, 렌더링하고, 이벤트를 처리하는 등의 작업을 보다 쉽게 만든다.
5. 선언형 프로그래밍 (목적을 그냥 먼저 말함.)
6. 대중성: React는 대중적인 UI 프레임워크 중 하나이기 때문에, 커뮤니티와 생태계가 매우 활발합니다. 이는 문제 해결 및 라이브러리, 툴, 지원 등을 얻기 쉬워지며, React 기술 스택을 습득하는 데도 도움이 됨.

### Context API와 Redux를 비교해주세요
-Context API와 Redux는 둘 다 React 애플리케이션에서 상태 관리를 위한 도구입니다..
Context API는 컴포넌트 트리 안에서 전역적(global)으로 데이터를 공유할 수 있는 방법을 제공하고,주로 프로젝트의 전역 상태(global state)를 관리하기 위해 사용됩니다.

Context API는 간단하게 구현할 수 있고 Redux보다 적은 코드로 구현할 수 있으며, 상태가 불변성을 유지하지 않아도 되지만, 복잡한 상태 관리가 필요한 경우에는 Redux보다 한계가 있다는 단점이 있습니다..

Redux도 애플리케이션의 상태 관리를 위한 도구로, Flux 아키텍처를 기반으로 졌는데,. Redux는 상태를 하나의 스토어(store)에 저장하고, 상태 변경을 위한 액션(action)을 발생시킵니다. 이후에 상태를 변경하기 위해 리듀서(reducer)가 실행됩니다.

Redux는 복잡한 상태 관리를 위한 도구로, 상태의 불변성을 유지하고 비동기 작업을 처리할 수 있습니다. 그러나 코드량이 많고 Context API보다 구현이 복잡합니다. 또한, 여러 컴포넌트에서 사용하는 경우에는 사용하기에 불편할 수 있습니다.

### React의 라이프사이클에 대해 설명해주세요.
라이프사이클 메서드는 컴포넌트가 브라우저상에 나타나고, 업데이트되고, 사라지게 될 때 호출되는 메서드들 입니다. 

-마운팅(Mounting)
마운팅은 React 컴포넌트가 생성되고, DOM에 삽입될 때의 라이프사이클 메서드입니다.

-업데이트(Updating)
업데이트는 컴포넌트의 상태나 프롭스가 변경될 때의 라이프사이클 메서드입니다.

-언마운팅(Unmounting)
언마운팅은 컴포넌트가 DOM에서 제거될 때의 라이프사이클 메서드입니다.

### useMemo와 useCallback에 대해 설명해 주세요.
useMemo와 useCallback은 React에서 최적화를 위해 사용되는 Hook입니다. 이 두 Hook은 대체로 비슷한 목적을 가지고 있지만,몇 가지 차이점이 있습니다.

1. **반환 값**

useMemo는 함수의 반환 값을 캐싱하고,useCallback은 함수 자체를 캐싱합니다. 그래서, useMemo는 비용이 많이 드는 함수의 반환값을 캐싱하고, useCallback은 반복적으로 호출되는 함수 자체를 캐싱하여 성능을 최적화합니다

1. **사용 용도**

useMemo는 성능이 느린 계산을 수행하는 함수의 결과를 캐싱하고, 이전에 계산된 값을 재사용하는 데 사용됩니다.

useCallback은 자식 컴포넌트에게 전달되는 함수를 캐싱하고, 자식 컴포넌트에서 동일한 함수를 계속해서 생성하지 않도록 합니다.

1. **사용 시점**

useMemo는 렌더링 중 계산 비용이 많이 드는 작업이 필요할 때 사용됩니다. 이전에 계산된 값을 사용하여 렌더링을 최적화합니다.

useCallback은 렌더링 중 자식 컴포넌트에게 전달되는 함수가 필요할 때 사용됩니다. 이전에 생성된 함수를 사용하여 렌더링을 최적화합니다.

1. **의존성 배열**

useMemo와 useCallback 모두 의존성 배열을 가지고 있습니다. 이 배열은 Hook이 의존하는 변수를 나타냅니다. 의존성 배열이 변경되면 useMemo와 useCallback 모두 이전에 캐싱된 값을 무효화하고 다시 계산합니다.

.

**`useMemo`**은 계산 비용이 많이 드는 함수의 결과 값을 기억하고, 이전과 동일한 입력이 주어졌을 때 이전에 계산한 결과 값을 반환합니다. 이는 동일한 입력이 주어졌을 때 매번 계산하는 것이 아니라, 이전 결과 값을 재사용하여 성능을 향상시키는 데 도움이 됩니다.

**`useCallback`**은 함수를 메모이제이션하여 이전과 동일한 함수 인스턴스를 반환합니다. 이전과 동일한 함수 인스턴스를 사용하면, 불필요한 렌더링을 줄이고 메모리 사용량을 줄일 수 있습니다.

**Virtual DOM**
Virtual DOM은 React에서 사용되는 개념으로, 브라우저의 실제 DOM과 유사한 구조를 가지지만, 메모리 상에 존재하는 가상의 DOM입니다. React는 컴포넌트 상태(state)의 변경사항을 감지하면, 이를 Virtual DOM에 반영합니다. 그리고 Virtual DOM과 이전 Virtual DOM의 차이를 비교하여 실제 DOM을 최소한으로 업데이트하는 최적화 작업을 수행합니다.

Virtual DOM의 이점은 다음과 같습니다.

1. 성능 개선: React는 변경사항을 바로 실제 DOM에 적용하는 것이 아니라, 먼저 Virtual DOM에 반영한 후, 이전 Virtual DOM과 비교하여 변경된 부분만 실제 DOM에 적용합니다. 이렇게 함으로써, 필요한 최소한의 DOM 조작만 수행하여 성능을 향상시킬 수 있습니다.
2. 다양한 환경 지원: React는 Virtual DOM을 사용하여, 브라우저 환경 뿐만 아니라, 서버 사이드 렌더링 등 다양한 환경에서도 동작할 수 있습니다.
3. 복잡한 UI 관리: React는 Virtual DOM을 사용하여 복잡한 UI를 관리하기 쉬워집니다. 컴포넌트의 상태를 쉽게 추적하고, 변경사항을 빠르게 적용하여 UI를 관리할 수 있습니다.
4. 개발 생산성 향상: Virtual DOM은 React의 추상화 계층으로, 프로그래머가 DOM 조작을 직접 수행하지 않아도 되어 개발 생산성을 향상시킵니다.

React에서는 Virtual DOM이 기본적으로 사용되며, 이를 활용하여 성능을 최적화하고, 개발 생산성을 향상시키는 것이 좋습니다.

### 3.suspense가 뭔가요? 
Suspense는 아직 렌더링이 준비되지 않은 컴포넌트가 있을때 로딩 화면을 보여주고 로딩이 완료되면 해당 컴포넌트를 보여주는 React에 내장되어 있는 기능

SPA(Single-Page-Application)의 단점은 한번에 사용하지 않는 모든 컴포넌트까지 불러오기 때문에 첫 화면이 렌더링 될때까지의 시간이 오래걸리는 것이다. React는 lazy를 통해 컴포넌트를 동적으로 import를 할 수 있기 때문에 이를 사용하면 초기 렌더링 지연시간을 어느정도 줄일 수 있다.
const SomeComponent = React.lazy(() => import('./SomeComponent'));
Router로 분기가 나누어진 컴포넌트들을 위 코드처럼 lazy를 통해 import하면 해당 path로 이동할때 컴포넌트를 불러오게 되는데 이 과정에서 로딩하는 시간이 생기게 된다. 이 로딩되는 시간동안 로딩 화면을 보여지도록 해주는 역할을 하는 것이 바로 Suspense 이다.


