### 모듈 번들러에 대해서 아시나요?

**미리 준비한 답변**

**모듈 번들러**(module bundler)는 **Module + Bundling**이 혼합된 단어인데, 모듈은 '분리된 코드 조각'을 의미하고 번들링은 '묶는다'는 의미입니다.

모듈 번들러는 웹 애플리케이션을 개발할 때 자바스크립트 **모듈들을 하나의 번들 파일로 묶어주는 도구**입니다. 이것을 통해서 여러 개의 자바스크립트 파일을 하나의 파일로 번들링하여 브라우저에서 불러오는 요청 수를 줄이고, 애플리케이션의 로딩 속도를 향상시킬 수 있습니다.

모듈 번들러는 주로 CommonJS나 AMD와 같은 모듈 시스템을 지원하며, 이러한 모듈 시스템에서는 각 모듈이 독립적으로 존재하며, 다른 모듈과의 의존성을 가지고 있습니다. 이러한 의존성 관계를 분석하여 필요한 모듈들을 하나의 번들 파일로 묶어주는 것이 모듈 번들러의 주요 기능입니다.

대표적인 모듈 번들러로는 **Webpack, Rollup, Parcel** 등이 있으며, 이들은 각각 다양한 기능과 설정을 제공합니다. Webpack은 모듈 번들링을 비롯한 다양한 기능을 제공하며, Rollup은 작은 라이브러리나 프로젝트에 적합하며, Parcel은 구성 없이 쉽게 사용할 수 있습니다.


### 이벤트 버블링, 캡처링, 위임에 대해 아는대로 말해주세요

이벤트 버블링, 캡처링, 위임은 모두 HTML과 JavaScript에서 이벤트 처리를 다룰 때 사용하는 개념입니다.

1. **이벤트 버블링(Event Bubbling)**
이벤트 버블링은 이벤트가 발생한 요소에서 시작해 부모 요소를 거슬러 올라가면서 처리되는 방식입니다. 이벤트가 발생한 요소에서 시작해 부모 요소를 차례로 탐색하면서 이벤트 핸들러가 실행됩니다. 이벤트 버블링은 가장 먼저 발생한 이벤트부터 처리되기 때문에, 자식 요소에서 발생한 이벤트가 부모 요소에 영향을 미치는 경우가 많습니다.
2. **이벤트 캡처링(Event Capturing)**
이벤트 캡처링은 이벤트가 발생한 요소의 가장 상위 요소부터 시작해 이벤트가 발생한 요소까지 내려오면서 처리되는 방식입니다. 이벤트 캡처링은 이벤트 버블링과 반대로 실행됩니다. 캡처링 단계에서 처리되는 이벤트 핸들러는 일반적으로 해당 요소에서 발생한 이벤트를 가로채거나 처리하기 위한 용도로 사용됩니다.
3. **이벤트 위임(Event Delegation)**
이벤트 위임은 자식 요소들이 가지고 있는 이벤트 핸들러를 부모 요소에 등록함으로써, 동적으로 생성된 자식 요소들도 이벤트를 처리할 수 있게 하는 방식입니다. 즉, 부모 요소에서 자식 요소들의 이벤트를 관리하는 것입니다. 이벤트 위임을 사용하면 동적으로 생성된 요소들도 이벤트를 처리할 수 있기 때문에 코드의 유지보수성을 높이고, 메모리 사용량을 줄일 수 있습니다. 이벤트 위임은 주로 JavaScript 라이브러리나 프레임워크에서 사용되는 패턴 중 하나입니다.

### RESTful API에 대해 설명해 주세요. 
RESTful API는 두 컴퓨터 시스템이 인터넷을 통해 정보를 안전하게 교환하기 위해 사용하는 인터페이스입니다.RESTful API는 HTTP 프로토콜을 기반으로 하며, 클라이언트와 서버 사이의 통신을 위해 주로 JSON 형식을 사용합니다. RESTful API를 사용했을 때 가지는 이점은 확장성, 유연성,독립성이 있습니다. 
RESTful API에서 자원(Resource)은 URI(Uniform Resource Identifier)로 표현되며, HTTP 메서드(GET, POST, PUT, DELETE)를 사용하여 CRUD 기능을 수행합니다. 각각의 HTTP 메서드는 자원에 대한 다음과 같은 작업을 수행합니다.
•	GET: 자원을 조회합니다.
•	POST: 새로운 자원을 생성합니다.
•	PUT: 기존 자원을 수정합니다.
•	DELETE: 자원을 삭제합니다.
RESTful API는 HTTP 프로토콜의 Stateless 특성을 사용하여 서버에서 세션 정보를 유지하지 않고, 클라이언트와 서버 사이의 통신을 위한 데이터를 모두 요청(Request)과 응답(Response)에 포함시킵니다. 이러한 Stateless 특성은 서버의 확장성과 성능을 향상시키는 데 도움이 됩니다.
RESTful API는 간결하고 직관적인 인터페이스를 제공하여, 다양한 클라이언트와 서버 사이의 상호 운용성을 보장합니다. 또한, RESTful API는 웹 개발의 기본 원칙을 따르기 때문에, 이를 이해하는 것이 비교적 쉽고, 구현하기도 간단합니다. 따라서, RESTful API는 현대적인 웹 어플리케이션에서 자주 사용되는 아키텍처 스타일 중 하나입니다.



### 브라우저 저장소이 무엇인가요? 

브라우저 저장소(Browser Storage)는 웹 브라우저에서 데이터를 저장하는 기능입니다. 이 기능을 사용하면 브라우저를 닫았다가 다시 열어도 데이터를 유지할 수 있습니다.대표적인 브라우저 저장소에는 쿠키(Cookie), 로컬 스토리지(Local Storage), 세션 스토리지(Session Storage)

1.	쿠키(Cookie) : 서버와 클라이언트 간의 상태 정보를 유지하기 위해 사용되는 작은 데이터 파일입니다. 쿠키는 브라우저에 저장되며, 웹사이트에서 쿠키를 읽거나 쓸 수 있습니다. 
쿠키는 주로 로그인 정보나 사용자 환경 설정 등을 저장하는 데 사용됩니다.

2.	로컬 스토리지(Local Storage) : 브라우저 내에 키-값 쌍을 저장하는 기능입니다. 로컬 스토리지는 브라우저를 닫았다가 다시 열어도 데이터를 유지합니다. 로컬 스토리지는 쿠키보다 용량이 크고, 서버에 전송되지 않으므로 보안성이 높습니다.

3.	세션 스토리지(Session Storage) : 로컬 스토리지와 비슷하지만, 세션이 끝나면 저장된 데이터가 삭제됩니다. 세션 스토리지는 보통 로그인 정보 등을 저장하는 데 사용됩니다.

### 객체지향 프로그래밍에 대해 설명해 주세요.
객체지향 프로그래밍(Object-Oriented Programming, OOP)은 객체들의 집합으로 프로그램의 상호작용을 표현하며 데이터를 객체로 취급하여 객체 내부에 선언된 메서드를 활용하는 방식입니다. 설계에 많은 시간이 소요되며, 처리속도가 다른 프로그래밍 패러다임에 비해 상대적으로 느리다.  

객체는 속성(Attribute)과 동작(Method)을 가지며, 이러한 속성과 동작은 클래스(Class)라는 템플릿에 정의됩니다. 객체는 클래스의 인스턴스(Instance)로 생성되며, 각 객체는 고유한 상태를 유지하고 클래스에 정의된 메서드를 수행할 수 있습니다.


**객체지향의 특징**

- 추상화 : 복잡한 시스템으로부터 핵심적인 개념 또는 기능을 간추려낸것
- 캡슐화 : 객체의 속성과 메서드를 하나로 묶고 일부를 외부에 감추어 은닉하는것.
- 상속성 : 상위클래스의 특성을 하위 클래스가 이어받아 재사용하거나 확장하는것. 코드의 재사용이나 계층적인 관계생성 유지보수성에 중요한 역할을한다.
- 다형성 : 하나의 메서드나 클래스가 다양한 방법으로 동작하는것을 말함. 대표적으로 오버로딩과 오버라이딩이있다.

객체지향 프로그래밍은 대규모 소프트웨어 개발에서 특히 효과적이며, 현대 프로그래밍 언어 대부분이 객체지향 프로그래밍을 지원하고 있습니다.

**오버로딩과 오버라이딩의 차이?**

- 오버로딩: 같은이름을 가진 메서드를 여러개 두는 것을 말함.
- 오버라이딩: 상위 클래스로부터 상속받은 메서드를 하위 클래스가 재정의 하는것을 의미

**객체지향 프로그래밍 설계시 SOLID원칙에 대해서 아시나요?**

SOLID 원칙은 객체 지향 프로그래밍(OOP)에서 소프트웨어 설계를 위한 다섯 가지 원칙을 말합니다. 이러한 원칙은 소프트웨어 설계의 유연성, 확장성, 유지보수성을 높이기 위해 개발되었습니다.

1. 단일 책임 원칙 (Single Responsibility Principle, SRP)
하나의 클래스는 단 하나의 책임만 가져야 합니다. 이를 통해 클래스를 변경하는 이유를 최소화하고, 유지보수성을 높일 수 있습니다.
2. 개방-폐쇄 원칙 (Open-Closed Principle, OCP)
소프트웨어 요구사항이 변경될 때, 기존의 코드는 변경되지 않아야 합니다. 새로운 기능이 추가될 때는 기존 코드를 변경하는 것이 아니라, 새로운 코드를 추가하는 방식으로 확장해야 합니다.
3. 리스코프 치환 원칙 (Liskov Substitution Principle, LSP)
서브 클래스는 언제나 기반 클래스로 대체할 수 있어야 합니다. 이를 통해 상속 관계에서의 일관성을 유지하고, 다형성을 구현할 수 있습니다.
4. 인터페이스 분리 원칙 (Interface Segregation Principle, ISP)
클라이언트는 사용하지 않는 메서드에 의존하도록 강제되어서는 안 됩니다. 인터페이스는 클라이언트가 필요로 하는 메서드만 제공해야 합니다.
5. 의존 역전 원칙 (Dependency Inversion Principle, DIP)
고수준 모듈은 저수준 모듈에 의존해서는 안 됩니다. 두 모듈 모두 추상화된 인터페이스에 의존해야 합니다. 이를 통해 코드의 결합도를 낮추고, 유지보수성을 높일 수 있습니다.

이러한 SOLID 원칙은 객체 지향 소프트웨어 설계에서 가이드라인으로 사용되며, 객체 지향 설계의 특성을 잘 살리기 위한 필수적인 요소입니다. 이를 적용하면 유지보수성이 높은, 확장성이 좋은 소프트웨어를 만들 수 있습니다.
### 상태 불변성?

상태 불변성(Immutability)은 객체의 상태를 변경할 수 없는 것을 말합니다. 객체가 생성된 이후에는 그 상태가 변경되지 않으며, 새로운 객체가 생성될 때만 변경이 일어납니다. 이는 함수형 프로그래밍에서 중요한 개념으로, 함수형 프로그래밍에서는 가능한 한 불변성을 유지하도록 권장합니다.

상태 불변성을 유지하는 것은 다음과 같은 이점이 있습니다.

1. 코드가 간결해집니다.
불변한 객체는 수정되지 않으므로, 코드에서 상태를 변경하거나 갱신하는 로직을 추가할 필요가 없습니다.
2. 코드의 예측 가능성이 높아집니다.
객체가 변경되지 않으므로, 코드 실행 중에 예기치 않은 상태 변경이 발생하는 경우를 줄일 수 있습니다.
3. 다중 스레드 환경에서 안정성이 높아집니다.
불변한 객체는 여러 스레드에서 공유할 수 있으므로, 상태 동기화와 관련된 문제를 해결할 필요가 없습니다.
