### 모듈 번들러에 대해서 아시나요?

**미리 준비한 답변**

**모듈 번들러**(module bundler)는 **Module + Bundling**이 혼합된 단어인데, 모듈은 '분리된 코드 조각'을 의미하고 번들링은 '묶는다'는 의미입니다.

모듈 번들러는 웹 애플리케이션을 개발할 때 자바스크립트 **모듈들을 하나의 번들 파일로 묶어주는 도구**입니다. 이것을 통해서 여러 개의 자바스크립트 파일을 하나의 파일로 번들링하여 브라우저에서 불러오는 요청 수를 줄이고, 애플리케이션의 로딩 속도를 향상시킬 수 있습니다.

모듈 번들러는 주로 CommonJS나 AMD와 같은 모듈 시스템을 지원하며, 이러한 모듈 시스템에서는 각 모듈이 독립적으로 존재하며, 다른 모듈과의 의존성을 가지고 있습니다. 이러한 의존성 관계를 분석하여 필요한 모듈들을 하나의 번들 파일로 묶어주는 것이 모듈 번들러의 주요 기능입니다.

대표적인 모듈 번들러로는 **Webpack, Rollup, Parcel** 등이 있으며, 이들은 각각 다양한 기능과 설정을 제공합니다. Webpack은 모듈 번들링을 비롯한 다양한 기능을 제공하며, Rollup은 작은 라이브러리나 프로젝트에 적합하며, Parcel은 구성 없이 쉽게 사용할 수 있습니다.


### 이벤트 버블링, 캡처링, 위임에 대해 아는대로 말해주세요

이벤트 버블링, 캡처링, 위임은 모두 HTML과 JavaScript에서 이벤트 처리를 다룰 때 사용하는 개념입니다.

1. **이벤트 버블링(Event Bubbling)**
이벤트 버블링은 이벤트가 발생한 요소에서 시작해 부모 요소를 거슬러 올라가면서 처리되는 방식입니다. 이벤트가 발생한 요소에서 시작해 부모 요소를 차례로 탐색하면서 이벤트 핸들러가 실행됩니다. 이벤트 버블링은 가장 먼저 발생한 이벤트부터 처리되기 때문에, 자식 요소에서 발생한 이벤트가 부모 요소에 영향을 미치는 경우가 많습니다.
2. **이벤트 캡처링(Event Capturing)**
이벤트 캡처링은 이벤트가 발생한 요소의 가장 상위 요소부터 시작해 이벤트가 발생한 요소까지 내려오면서 처리되는 방식입니다. 이벤트 캡처링은 이벤트 버블링과 반대로 실행됩니다. 캡처링 단계에서 처리되는 이벤트 핸들러는 일반적으로 해당 요소에서 발생한 이벤트를 가로채거나 처리하기 위한 용도로 사용됩니다.
3. **이벤트 위임(Event Delegation)**
이벤트 위임은 자식 요소들이 가지고 있는 이벤트 핸들러를 부모 요소에 등록함으로써, 동적으로 생성된 자식 요소들도 이벤트를 처리할 수 있게 하는 방식입니다. 즉, 부모 요소에서 자식 요소들의 이벤트를 관리하는 것입니다. 이벤트 위임을 사용하면 동적으로 생성된 요소들도 이벤트를 처리할 수 있기 때문에 코드의 유지보수성을 높이고, 메모리 사용량을 줄일 수 있습니다. 이벤트 위임은 주로 JavaScript 라이브러리나 프레임워크에서 사용되는 패턴 중 하나입니다.




### 브라우저 저장소이 무엇인가요? 

브라우저 저장소(Browser Storage)는 웹 브라우저에서 데이터를 저장하는 기능입니다. 이 기능을 사용하면 브라우저를 닫았다가 다시 열어도 데이터를 유지할 수 있습니다.대표적인 브라우저 저장소에는 쿠키(Cookie), 로컬 스토리지(Local Storage), 세션 스토리지(Session Storage)

1.	쿠키(Cookie) : 서버와 클라이언트 간의 상태 정보를 유지하기 위해 사용되는 작은 데이터 파일입니다. 쿠키는 브라우저에 저장되며, 웹사이트에서 쿠키를 읽거나 쓸 수 있습니다. 
쿠키는 주로 로그인 정보나 사용자 환경 설정 등을 저장하는 데 사용됩니다.

2.	로컬 스토리지(Local Storage) : 브라우저 내에 키-값 쌍을 저장하는 기능입니다. 로컬 스토리지는 브라우저를 닫았다가 다시 열어도 데이터를 유지합니다. 로컬 스토리지는 쿠키보다 용량이 크고, 서버에 전송되지 않으므로 보안성이 높습니다.

3.	세션 스토리지(Session Storage) : 로컬 스토리지와 비슷하지만, 세션이 끝나면 저장된 데이터가 삭제됩니다. 세션 스토리지는 보통 로그인 정보 등을 저장하는 데 사용됩니다.

### 객체지향 프로그래밍에 대해 설명해 주세요.
객체지향 프로그래밍(Object-Oriented Programming, OOP)은 객체들의 집합으로 프로그램의 상호작용을 표현하며 데이터를 객체로 취급하여 객체 내부에 선언된 메서드를 활용하는 방식입니다. 설계에 많은 시간이 소요되며, 처리속도가 다른 프로그래밍 패러다임에 비해 상대적으로 느리다.  

객체는 속성(Attribute)과 동작(Method)을 가지며, 이러한 속성과 동작은 클래스(Class)라는 템플릿에 정의됩니다. 객체는 클래스의 인스턴스(Instance)로 생성되며, 각 객체는 고유한 상태를 유지하고 클래스에 정의된 메서드를 수행할 수 있습니다.


**객체지향의 특징**

- 추상화 : 복잡한 시스템으로부터 핵심적인 개념 또는 기능을 간추려낸것
- 캡슐화 : 객체의 속성과 메서드를 하나로 묶고 일부를 외부에 감추어 은닉하는것.
- 상속성 : 상위클래스의 특성을 하위 클래스가 이어받아 재사용하거나 확장하는것. 코드의 재사용이나 계층적인 관계생성 유지보수성에 중요한 역할을한다.
- 다형성 : 하나의 메서드나 클래스가 다양한 방법으로 동작하는것을 말함. 대표적으로 오버로딩과 오버라이딩이있다.

객체지향 프로그래밍은 대규모 소프트웨어 개발에서 특히 효과적이며, 현대 프로그래밍 언어 대부분이 객체지향 프로그래밍을 지원하고 있습니다.

**오버로딩과 오버라이딩의 차이?**
오버로딩(Overloading)과 오버라이딩(Overriding)은 객체지향 프로그래밍에서 다형성을 구현하기 위해 사용되는 개념

- 오버로딩: 같은이름을 가진 메서드를 여러개 두는 것을 말함.메서드나 생성자의 이름은 동일하지만, 매개변수의 개수, 타입 또는 순서가 다른 다양한 버전을 가지는 것이 특징.
- 오버라이딩: 상위 클래스로부터 상속받은 메서드를 하위 클래스가 재정의 하는것을 의미.부모 클래스의 메서드를 자식 클래스에서 구체적인 동작으로 변경해야 하는 경우사

**객체지향 프로그래밍 설계시 SOLID원칙에 대해서 아시나요?**

SOLID 원칙은 객체 지향 프로그래밍(OOP)에서 소프트웨어 설계를 위한 다섯 가지 원칙을 말합니다. 이러한 원칙은 소프트웨어 설계의 유연성, 확장성, 유지보수성을 높이기 위해 개발되었습니다.

1. 단일 책임 원칙 (Single Responsibility Principle, SRP)
하나의 클래스는 단 하나의 책임만 가져야 합니다. 이를 통해 클래스를 변경하는 이유를 최소화하고, 유지보수성을 높일 수 있습니다.
2. 개방-폐쇄 원칙 (Open-Closed Principle, OCP)
소프트웨어 요구사항이 변경될 때, 기존의 코드는 변경되지 않아야 합니다. 새로운 기능이 추가될 때는 기존 코드를 변경하는 것이 아니라, 새로운 코드를 추가하는 방식으로 확장해야 합니다.
3. 리스코프 치환 원칙 (Liskov Substitution Principle, LSP)
서브 클래스는 언제나 기반 클래스로 대체할 수 있어야 합니다. 이를 통해 상속 관계에서의 일관성을 유지하고, 다형성을 구현할 수 있습니다.
4. 인터페이스 분리 원칙 (Interface Segregation Principle, ISP)
클라이언트는 사용하지 않는 메서드에 의존하도록 강제되어서는 안 됩니다. 인터페이스는 클라이언트가 필요로 하는 메서드만 제공해야 합니다.
5. 의존 역전 원칙 (Dependency Inversion Principle, DIP)
고수준 모듈은 저수준 모듈에 의존해서는 안 됩니다. 두 모듈 모두 추상화된 인터페이스에 의존해야 합니다. 이를 통해 코드의 결합도를 낮추고, 유지보수성을 높일 수 있습니다.

이러한 SOLID 원칙은 객체 지향 소프트웨어 설계에서 가이드라인으로 사용되며, 객체 지향 설계의 특성을 잘 살리기 위한 필수적인 요소입니다. 이를 적용하면 유지보수성이 높은, 확장성이 좋은 소프트웨어를 만들 수 있습니다.
### 상태 불변성?

상태 불변성(Immutability)은 객체의 상태를 변경할 수 없는 것을 말합니다. 객체가 생성된 이후에는 그 상태가 변경되지 않으며, 새로운 객체가 생성될 때만 변경이 일어납니다. 이는 함수형 프로그래밍에서 중요한 개념으로, 함수형 프로그래밍에서는 가능한 한 불변성을 유지하도록 권장합니다.

상태 불변성을 유지하는 것은 다음과 같은 이점이 있습니다.

1. 코드가 간결해집니다.
불변한 객체는 수정되지 않으므로, 코드에서 상태를 변경하거나 갱신하는 로직을 추가할 필요가 없습니다.
2. 코드의 예측 가능성이 높아집니다.
객체가 변경되지 않으므로, 코드 실행 중에 예기치 않은 상태 변경이 발생하는 경우를 줄일 수 있습니다.
3. 다중 스레드 환경에서 안정성이 높아집니다.
불변한 객체는 여러 스레드에서 공유할 수 있으므로, 상태 동기화와 관련된 문제를 해결할 필요가 없습니다.

### 리프로우 & 리페인팅
Reflow와 Repaint는 웹 페이지의 렌더링과 관련된 개념

1. Reflow: Reflow는 브라우저에서 요소의 크기, 위치, 레이아웃 등이 변경될 때 발생하는 프로세스입니다. 요소의 크기나 위치가 변경되면 해당 요소와 관련된 다른 요소들의 위치와 레이아웃도 다시 계산되어야 합니다. 이는 브라우저가 렌더 트리를 다시 구성하고 레이아웃을 업데이트하는 작업을 의미합니다. Reflow는 비용이 많이 들어가는 작업으로, 성능 저하의 원인이 될 수 있습니다.

2. Repaint: Repaint는 브라우저가 요소의 스타일을 다시 그리는 작업입니다. 요소의 스타일에 변경이 없지만, 렌더링이 다시 발생하여 다시 그려져야 할 때 Repaint가 발생합니다. 예를 들어, 요소의 배경색이나 글자 색상이 변경되었을 때 해당 요소를 다시 그려야 합니다. Reflow보다는 비용이 적게 드는 작업이지만 여전히 성능에 영향을 줄 수 있습니다.

브라우저는 최적화를 통해 Reflow와 Repaint의 발생을 최소화하려고 합니다. 그러나 CSS 작성 시 스타일 변경의 영향 범위를 고려하고, JavaScript로 DOM 요소를 조작할 때도 주의하여 성능을 향상시킬 수 있습니다.


### 브라우저 
브라우저 저장소(Browser Storage)는 웹 브라우저에서 데이터를 저장하는 기능입니다. 이 기능을 사용하면 브라우저를 닫았다가 다시 열어도 데이터를 유지할 수 있습니다. 대표적인 브라우저 저장소에는 쿠키(Cookie), 로컬 스토리지(Local Storage), 세션 스토리지(Session Storage) 등이 있습니다.

1. **쿠키(Cookie) :** 
- 만료 기한이 있는 키-값 저장소이다.
- 4KB까지 데이터 저장 가능
- 서버와 클라이언트 간의 상태 정보를 유지하기 위해 사용되는 작은 데이터 파일
- 쿠키는 브라우저에 저장되며, 웹사이트에서 쿠키를 읽거나 쓸 수 있다.
- 쿠키는 주로 로그인 정보나 사용자 환경 설정 등을 저장하는 데 사용됩니다.

1. **로컬 스토리지(Local Storage) :** 
- 만료기한이 없는 브라우저 내에 키-값 쌍 저장소. 10MB까지 저장가능.
- 로컬 스토리지는 브라우저를 닫았다가 다시 열어도 데이터유지
- 로컬 스토리지는 쿠키보다 용량이 크고, 서버에 전송되지 않으므로 보안성이 높다.

1. **세션 스토리지(Session Storage)** :
- 로컬 스토리지와 비슷하지만, 세션이 끝나면 저장된 데이터가 삭제.
- 만료기한이 없는 브라우저 내에 키-값 쌍 저장소. 5MB까지 저장가능
- 탭단위로 세션스토리지를 생성, 탭을 닫을때 해당 데이터가 삭제
- 세션 스토리지는 보통 로그인 정보 등을 저장하는 데 사용됩니다.

브라우저 저장소는 브라우저를 닫았다가 다시 열어도 데이터를 유지할 수 있기 때문에, 사용자 경험을 개선하고 빠르고 효율적인 웹 애플리케이션을 만드는 데 도움이 됩니다.




## 불변성을 유지하려면 어떻게 해야 하나요?
객체를 const로 선언합니다.
객체의 속성에 setter 메서드를 사용하지 않습니다.
Immutable.js와 같은 불변 라이브러리를 사용합니다.
객체를 const로 선언하면 객체의 값을 변경할 수 없습니다. setter 메서드는 객체의 속성을 변경하는 데 사용되는 메서드입니다. setter 메서드를 사용하지 않으면 객체의 값을 변경할 수 없습니다. Immutable.js는 불변 자료구조를 제공하는 라이브러리입니다. Immutable.js를 사용하면 불변 자료구조를 쉽게 사용할 수 있습니다.

불변성을 유지하면 다음과 같은 이점이 있습니다.

코드가 간결하고 이해하기 쉽습니다.
버그 발생 가능성이 줄어듭니다.
성능이 향상됩니다.
불변성은 자바스크립트에서 중요한 개념입니다. 불변성을 유지하면 코드의 품질을 향상시킬 수 있습니다.
## 깊은 복사와 얕은 복사에 대해 설명해 주세요.
1. 얕은 복사(Shallow Copy):
    - 얕은 복사는 원본 객체나 배열의 참조(reference)를 복사합니다.
    - 복사된 객체나 배열은 원본과 동일한 참조를 가리키기 때문에 원본의 변경이 복사본에 영향을 미칠 수 있습니다.
    - 얕은 복사는 주로 단순한 데이터 구조에서 사용됩니다.
    - JavaScript에서는 **`Object.assign()`** 메서드나 전개 연산자(**`...`**)를 사용하여 얕은 복사를 수행할 수 있습니다.
2. 깊은 복사(Deep Copy):
    - 깊은 복사는 원본 객체나 배열의 값 자체를 재귀적으로 복사합니다.
    - 복사된 객체나 배열은 완전히 독립적인 복사본이므로 원본의 변경이 복사본에 영향을 미치지 않습니다.
    - 중첩된 객체나 배열이 많거나, 원본과 복사본을 분리하여 독립적으로 사용해야 할 때 유용합니다.
    - JavaScript에서는 JSON.stringify()와 JSON.parse()를 조합하여 깊은 복사를 수행할 수 있습니다. 또는 라이브러리인 Lodash나 Immutable.js와 같은 도구를 사용할 수도 있습니다
## 프론트엔드 빌드 시스템에 대해서 설명해 주세요.
## CSR 과 SSR의 차이를 설명해주세요.
렌더링이 클라이언트 쪽에서 일어난다.즉, 서버는 요청을 받으면 클라이언트에 HTML과 JS를 보내준다.

![image](https://github.com/theo-jin/CsAndBooks/assets/83561523/34adbad0-4b8e-40f0-91c0-0eaa54a29cfc)

1.  User가 Website 요청을 보냄.

2. CDN이 HTML 파일과 JS로 접근할 수 있는 링크를 클라이언트로 보낸다.

CDN : aws의 cloudflare를 생각하면 됨. 엔드 유저의 요청에 '물리적'으로 가까운 서버에서 요청에 응답하는 방식

3. 클라이언트는 HTML과 JS를 다운로드 받는다.(**이때 SSR과 달리 유저는 아무것도 볼 수 없다**

.)

4. 브라우저가 자바스크립트를 다운받음.

5. 다운이 완료된 JS가 실행된다. 데이터를 위한 API가 호출된다.

(이때 유저들은 placeholder를 보게된다. )

6. 서버가 API로부터의 요청에 응답한다.

7. API로부터 받아온 data를 placeholder 자리에 넣어준다. 이제 페이지는 상호작용이 가능해진다.

클라이언트는 그것을 받아 렌더링을 시작한다.

SSR
![image](https://github.com/theo-jin/CsAndBooks/assets/83561523/8613eaf1-4068-40b5-b588-368e40893a31)

1. User가 Website 요청을 보냄.
2. Server는 'Ready to Render'. 즉, 즉시 렌더링 가능한 html파일을 만든다.
(리소스 체크, 컴파일 후 완성된 HTML 컨텐츠로 만든다.)
3. 클라이언트에 전달되는 순간, 이미 렌더링 준비가 되어있기 때문에 HTML은 즉시 렌더링 된다.
    
    그러나 사이트 자체는 조작 불가능하다. (Javascript가 읽히기 전이다.)
    
4. 클라이언트가 자바스크립트를 다운받는다.
5. 다운 받아지고 있는 사이에 유저는 컨텐츠는 볼 수 있지만 사이트를 조작 할 수는 없다. 이때의 사용자 조작을 기억하고 있는다.
6. 브라우저가 Javascript 프레임워크를 실행한다.
7. JS까지 성공적으로 컴파일 되었기 때문에 기억하고 있던 사용자 조작이 실행되고 이제 웹 페이지는 상호작용 가능해진다.

https://hahahoho5915.tistory.com/52

## SEO(Search Engine Optimization)

- 대부분의 웹 크롤러, 봇들은 JS를 실행시키지 못하고 HTML에서만 컨텐츠를 수집하기 때문에
    
    CSR 방식으로 개발된 페이지를 빈 페이지로 인식하게 됩니다.
    
- SSR 방식은 View를 서버에서 전부 렌더링하기 때문에 HTML에 모든 컨텐츠가 저장되어 있어 SEO를 사용하는데 문제가 없습니다.
## 세션 기반 인증과 토큰 기반 인증에 대해 설명해 주세요.

**인증(Autenticaion)**: 유저가 누구인지 확인하는 절차

• 특정 서비스에 일정 권한이 주어진 사용자임을 아이디와 패스워드를 통해 인증 받는 것

**인가(Authorization)**: 유저의 요청에 대한 권한을 확인하고 허가 해주는 것

- 인가를 하기 위해서는 반드시 인증이 선행되어야한다!
- 내 계정으로’만’ 할 수 있는 활동을 시도할 때 허가 해주는 것
- 

### 가비지 컬렉션
프로그램을 개발 하다 보면 유효하지 않은 메모리인 가바지(Garbage)가 발생하게 됩니다. 자바스크립트는 눈에 보이지 않는 곳에서 메모리 관리를 수행합니다.그러한 가비지 컬렉션 기준은 도달가능성이라는 개념을 사용해 메모리 관리를 수행합니다. 현재함수의 지역변수와 매개변수, 전역 변수와 같이 태생적으로 도달가능한값은 삭제당하지 않지만 도달하지 못하는 값은 메모리 할당을 해제합니다. 
그리고 이러한 가비지 컬렉션을 관리하는 알고리즘으로는 
Reference-Counting: 말 그대로 참조 개수를 카운팅하여 참조가 하나도 없으면 가비지로 판단하는 방법

Mark-and-Sweep: roots 라는 전역변수의 집합부터 시작하여, roots가 참조하는 객체 → 그 자식들이 참조하는 객체 → ...
이런식으로 접근 가능한 객체들을 선별하고, 접근이 불가능한 객체들을 가비지로 판단하는 방법이다.실행 컨텍스트가 소멸하는 순간, 접근하기 불가능한 객체가 되기 때문에 순환 참조는 발생하지 않는다.2012년부터 모든 최신 브라우저들이 Mark-and-Sweep 알고리즘으로 가비지 컬렉션을 진행

Mark-and-Sweep의 3가지 상태
모든 객체를 3가지 상태로 분류하여 가비지 여부를 판단한다.
1.	White : 아직 가비지 컬렉터가 탐색하지 못한 상태
2.	Gray : 가비지 컬렉터가 탐색했으나, 해당 객체가 참조하는 객체들은 탐색하지 못한 상태
3.	Black : 가비지 컬렉터가 탐색했고, 해당 객체가 참조하는 객체들도 탐색 완료한 상태
4.	

브라우저 렌더링 과정에 대해 설명해주세요 
웹 브라우저에 URL을 입력하면 웹 서버라 불리는 프로그램이 웹 브라우저에 웹 페이지를 제공한다.  웹 브라우저가 웹 서버에 연결하려면, 웹 서버가 실행중인 컴퓨터의 주소를 알아야 하는데, 이 주소를 IP 주소라 한다. 웹 브라우저와 웹 서버는 IP 주소를 이용하여 연결하기 때문에 도메인 이름을 IP 주소로 변환할 필요가 있는데, 이 때 사용하는 것이 바로 DNS(Domain Name Server)이다.웹 브라우저에서 URL을 입력하면, 웹 브라우저는 도메인 이름에 해당하는 IP 주소를 DNS에 요청하고, DNS는 IP주소를 응답으로 제공한다.
렌더링 엔진 동작과정은 이러한데 
1.	DOM트리 구축, CSSOM트리 구축
2.	렌더트리 구축 
3.	렌더트리 배치
4.	렌더 트리 그리기
1.DOM트리 구축, CSSOM트리 구축
•	HTML을 파싱하여 DOM 노드를 만든다. 이 DOM 노드들을 병합하여 DOM 트리를 만든다.
•	CSS를 파싱하여, CSSOM(CSS Object Model) 트리를 만들게 된다.
CSS파싱 과정은 바이트 > 문자 > 토큰 > 노드 > CSSOM 생성 순으로 HTML의 파싱과정과 동일하다.
2.렌더트리 구축 
CSSOM 트리와 DOM 트리를 결합하여, 표시해야 할 순서로 내용을 그려낼 수 있도록 하기 위해 렌더 트리를 형성한다. 이 과정을 Attachment라고 한다.

3. 렌더트리 배치
렌더 트리가 생성되고, 기기의 뷰포트 내에서 렌더 트리의 노드가 정확한 위치와 크기를 계산한다 과정을 배치(Layout) 또는 Reflow 라고 한다.
4.렌더 트리 그리기
렌더 트리의 각 노드를 화면의 실제 픽셀로 나타낼 때 Painting메서드가 호출된다. Painting 과정 후 브라우저 화면에 UI가 나타나게 된다.



