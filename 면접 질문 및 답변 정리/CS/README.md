### 모듈 번들러에 대해서 아시나요?

**미리 준비한 답변**

**모듈 번들러**(module bundler)는 **Module + Bundling**이 혼합된 단어인데, 모듈은 '분리된 코드 조각'을 의미하고 번들링은 '묶는다'는 의미입니다.

모듈 번들러는 웹 애플리케이션을 개발할 때 자바스크립트 **모듈들을 하나의 번들 파일로 묶어주는 도구**입니다. 이것을 통해서 여러 개의 자바스크립트 파일을 하나의 파일로 번들링하여 브라우저에서 불러오는 요청 수를 줄이고, 애플리케이션의 로딩 속도를 향상시킬 수 있습니다.

모듈 번들러는 주로 CommonJS나 AMD와 같은 모듈 시스템을 지원하며, 이러한 모듈 시스템에서는 각 모듈이 독립적으로 존재하며, 다른 모듈과의 의존성을 가지고 있습니다. 이러한 의존성 관계를 분석하여 필요한 모듈들을 하나의 번들 파일로 묶어주는 것이 모듈 번들러의 주요 기능입니다.

대표적인 모듈 번들러로는 **Webpack, Rollup, Parcel** 등이 있으며, 이들은 각각 다양한 기능과 설정을 제공합니다. Webpack은 모듈 번들링을 비롯한 다양한 기능을 제공하며, Rollup은 작은 라이브러리나 프로젝트에 적합하며, Parcel은 구성 없이 쉽게 사용할 수 있습니다.


### 이벤트 버블링, 캡처링, 위임에 대해 아는대로 말해주세요

이벤트 버블링, 캡처링, 위임은 모두 HTML과 JavaScript에서 이벤트 처리를 다룰 때 사용하는 개념입니다.

1. **이벤트 버블링(Event Bubbling)**
이벤트 버블링은 이벤트가 발생한 요소에서 시작해 부모 요소를 거슬러 올라가면서 처리되는 방식입니다. 이벤트가 발생한 요소에서 시작해 부모 요소를 차례로 탐색하면서 이벤트 핸들러가 실행됩니다. 이벤트 버블링은 가장 먼저 발생한 이벤트부터 처리되기 때문에, 자식 요소에서 발생한 이벤트가 부모 요소에 영향을 미치는 경우가 많습니다.
2. **이벤트 캡처링(Event Capturing)**
이벤트 캡처링은 이벤트가 발생한 요소의 가장 상위 요소부터 시작해 이벤트가 발생한 요소까지 내려오면서 처리되는 방식입니다. 이벤트 캡처링은 이벤트 버블링과 반대로 실행됩니다. 캡처링 단계에서 처리되는 이벤트 핸들러는 일반적으로 해당 요소에서 발생한 이벤트를 가로채거나 처리하기 위한 용도로 사용됩니다.
3. **이벤트 위임(Event Delegation)**
이벤트 위임은 자식 요소들이 가지고 있는 이벤트 핸들러를 부모 요소에 등록함으로써, 동적으로 생성된 자식 요소들도 이벤트를 처리할 수 있게 하는 방식입니다. 즉, 부모 요소에서 자식 요소들의 이벤트를 관리하는 것입니다. 이벤트 위임을 사용하면 동적으로 생성된 요소들도 이벤트를 처리할 수 있기 때문에 코드의 유지보수성을 높이고, 메모리 사용량을 줄일 수 있습니다. 이벤트 위임은 주로 JavaScript 라이브러리나 프레임워크에서 사용되는 패턴 중 하나입니다.

### RESTful API에 대해 설명해 주세요. 
RESTful API는 두 컴퓨터 시스템이 인터넷을 통해 정보를 안전하게 교환하기 위해 사용하는 인터페이스입니다.RESTful API는 HTTP 프로토콜을 기반으로 하며, 클라이언트와 서버 사이의 통신을 위해 주로 JSON 형식을 사용합니다. RESTful API를 사용했을 때 가지는 이점은 확장성, 유연성,독립성이 있습니다. 
RESTful API에서 자원(Resource)은 URI(Uniform Resource Identifier)로 표현되며, HTTP 메서드(GET, POST, PUT, DELETE)를 사용하여 CRUD 기능을 수행합니다. 각각의 HTTP 메서드는 자원에 대한 다음과 같은 작업을 수행합니다.
•	GET: 자원을 조회합니다.
•	POST: 새로운 자원을 생성합니다.
•	PUT: 기존 자원을 수정합니다.
•	DELETE: 자원을 삭제합니다.
RESTful API는 HTTP 프로토콜의 Stateless 특성을 사용하여 서버에서 세션 정보를 유지하지 않고, 클라이언트와 서버 사이의 통신을 위한 데이터를 모두 요청(Request)과 응답(Response)에 포함시킵니다. 이러한 Stateless 특성은 서버의 확장성과 성능을 향상시키는 데 도움이 됩니다.
RESTful API는 간결하고 직관적인 인터페이스를 제공하여, 다양한 클라이언트와 서버 사이의 상호 운용성을 보장합니다. 또한, RESTful API는 웹 개발의 기본 원칙을 따르기 때문에, 이를 이해하는 것이 비교적 쉽고, 구현하기도 간단합니다. 따라서, RESTful API는 현대적인 웹 어플리케이션에서 자주 사용되는 아키텍처 스타일 중 하나입니다.



### 브라우저 저장소이 무엇인가요? 

브라우저 저장소(Browser Storage)는 웹 브라우저에서 데이터를 저장하는 기능입니다. 이 기능을 사용하면 브라우저를 닫았다가 다시 열어도 데이터를 유지할 수 있습니다.대표적인 브라우저 저장소에는 쿠키(Cookie), 로컬 스토리지(Local Storage), 세션 스토리지(Session Storage)

1.	쿠키(Cookie) : 서버와 클라이언트 간의 상태 정보를 유지하기 위해 사용되는 작은 데이터 파일입니다. 쿠키는 브라우저에 저장되며, 웹사이트에서 쿠키를 읽거나 쓸 수 있습니다. 
쿠키는 주로 로그인 정보나 사용자 환경 설정 등을 저장하는 데 사용됩니다.

2.	로컬 스토리지(Local Storage) : 브라우저 내에 키-값 쌍을 저장하는 기능입니다. 로컬 스토리지는 브라우저를 닫았다가 다시 열어도 데이터를 유지합니다. 로컬 스토리지는 쿠키보다 용량이 크고, 서버에 전송되지 않으므로 보안성이 높습니다.

3.	세션 스토리지(Session Storage) : 로컬 스토리지와 비슷하지만, 세션이 끝나면 저장된 데이터가 삭제됩니다. 세션 스토리지는 보통 로그인 정보 등을 저장하는 데 사용됩니다.

### 객체지향 프로그래밍에 대해 설명해 주세요.
객체지향 프로그래밍(Object-Oriented Programming, OOP)은 객체들의 집합으로 프로그램의 상호작용을 표현하며 데이터를 객체로 취급하여 객체 내부에 선언된 메서드를 활용하는 방식입니다. 설계에 많은 시간이 소요되며, 처리속도가 다른 프로그래밍 패러다임에 비해 상대적으로 느리다.  

객체는 속성(Attribute)과 동작(Method)을 가지며, 이러한 속성과 동작은 클래스(Class)라는 템플릿에 정의됩니다. 객체는 클래스의 인스턴스(Instance)로 생성되며, 각 객체는 고유한 상태를 유지하고 클래스에 정의된 메서드를 수행할 수 있습니다.


**객체지향의 특징**

- 추상화 : 복잡한 시스템으로부터 핵심적인 개념 또는 기능을 간추려낸것
- 캡슐화 : 객체의 속성과 메서드를 하나로 묶고 일부를 외부에 감추어 은닉하는것.
- 상속성 : 상위클래스의 특성을 하위 클래스가 이어받아 재사용하거나 확장하는것. 코드의 재사용이나 계층적인 관계생성 유지보수성에 중요한 역할을한다.
- 다형성 : 하나의 메서드나 클래스가 다양한 방법으로 동작하는것을 말함. 대표적으로 오버로딩과 오버라이딩이있다.

객체지향 프로그래밍은 대규모 소프트웨어 개발에서 특히 효과적이며, 현대 프로그래밍 언어 대부분이 객체지향 프로그래밍을 지원하고 있습니다.

**오버로딩과 오버라이딩의 차이?**
오버로딩(Overloading)과 오버라이딩(Overriding)은 객체지향 프로그래밍에서 다형성을 구현하기 위해 사용되는 개념

- 오버로딩: 같은이름을 가진 메서드를 여러개 두는 것을 말함.메서드나 생성자의 이름은 동일하지만, 매개변수의 개수, 타입 또는 순서가 다른 다양한 버전을 가지는 것이 특징.
- 오버라이딩: 상위 클래스로부터 상속받은 메서드를 하위 클래스가 재정의 하는것을 의미.부모 클래스의 메서드를 자식 클래스에서 구체적인 동작으로 변경해야 하는 경우사

**객체지향 프로그래밍 설계시 SOLID원칙에 대해서 아시나요?**

SOLID 원칙은 객체 지향 프로그래밍(OOP)에서 소프트웨어 설계를 위한 다섯 가지 원칙을 말합니다. 이러한 원칙은 소프트웨어 설계의 유연성, 확장성, 유지보수성을 높이기 위해 개발되었습니다.

1. 단일 책임 원칙 (Single Responsibility Principle, SRP)
하나의 클래스는 단 하나의 책임만 가져야 합니다. 이를 통해 클래스를 변경하는 이유를 최소화하고, 유지보수성을 높일 수 있습니다.
2. 개방-폐쇄 원칙 (Open-Closed Principle, OCP)
소프트웨어 요구사항이 변경될 때, 기존의 코드는 변경되지 않아야 합니다. 새로운 기능이 추가될 때는 기존 코드를 변경하는 것이 아니라, 새로운 코드를 추가하는 방식으로 확장해야 합니다.
3. 리스코프 치환 원칙 (Liskov Substitution Principle, LSP)
서브 클래스는 언제나 기반 클래스로 대체할 수 있어야 합니다. 이를 통해 상속 관계에서의 일관성을 유지하고, 다형성을 구현할 수 있습니다.
4. 인터페이스 분리 원칙 (Interface Segregation Principle, ISP)
클라이언트는 사용하지 않는 메서드에 의존하도록 강제되어서는 안 됩니다. 인터페이스는 클라이언트가 필요로 하는 메서드만 제공해야 합니다.
5. 의존 역전 원칙 (Dependency Inversion Principle, DIP)
고수준 모듈은 저수준 모듈에 의존해서는 안 됩니다. 두 모듈 모두 추상화된 인터페이스에 의존해야 합니다. 이를 통해 코드의 결합도를 낮추고, 유지보수성을 높일 수 있습니다.

이러한 SOLID 원칙은 객체 지향 소프트웨어 설계에서 가이드라인으로 사용되며, 객체 지향 설계의 특성을 잘 살리기 위한 필수적인 요소입니다. 이를 적용하면 유지보수성이 높은, 확장성이 좋은 소프트웨어를 만들 수 있습니다.
### 상태 불변성?

상태 불변성(Immutability)은 객체의 상태를 변경할 수 없는 것을 말합니다. 객체가 생성된 이후에는 그 상태가 변경되지 않으며, 새로운 객체가 생성될 때만 변경이 일어납니다. 이는 함수형 프로그래밍에서 중요한 개념으로, 함수형 프로그래밍에서는 가능한 한 불변성을 유지하도록 권장합니다.

상태 불변성을 유지하는 것은 다음과 같은 이점이 있습니다.

1. 코드가 간결해집니다.
불변한 객체는 수정되지 않으므로, 코드에서 상태를 변경하거나 갱신하는 로직을 추가할 필요가 없습니다.
2. 코드의 예측 가능성이 높아집니다.
객체가 변경되지 않으므로, 코드 실행 중에 예기치 않은 상태 변경이 발생하는 경우를 줄일 수 있습니다.
3. 다중 스레드 환경에서 안정성이 높아집니다.
불변한 객체는 여러 스레드에서 공유할 수 있으므로, 상태 동기화와 관련된 문제를 해결할 필요가 없습니다.

### 리프로우 & 리페인팅
Reflow와 Repaint는 웹 페이지의 렌더링과 관련된 개념

1. Reflow: Reflow는 브라우저에서 요소의 크기, 위치, 레이아웃 등이 변경될 때 발생하는 프로세스입니다. 요소의 크기나 위치가 변경되면 해당 요소와 관련된 다른 요소들의 위치와 레이아웃도 다시 계산되어야 합니다. 이는 브라우저가 렌더 트리를 다시 구성하고 레이아웃을 업데이트하는 작업을 의미합니다. Reflow는 비용이 많이 들어가는 작업으로, 성능 저하의 원인이 될 수 있습니다.

2. Repaint: Repaint는 브라우저가 요소의 스타일을 다시 그리는 작업입니다. 요소의 스타일에 변경이 없지만, 렌더링이 다시 발생하여 다시 그려져야 할 때 Repaint가 발생합니다. 예를 들어, 요소의 배경색이나 글자 색상이 변경되었을 때 해당 요소를 다시 그려야 합니다. Reflow보다는 비용이 적게 드는 작업이지만 여전히 성능에 영향을 줄 수 있습니다.

브라우저는 최적화를 통해 Reflow와 Repaint의 발생을 최소화하려고 합니다. 그러나 CSS 작성 시 스타일 변경의 영향 범위를 고려하고, JavaScript로 DOM 요소를 조작할 때도 주의하여 성능을 향상시킬 수 있습니다.


### 브라우저 
브라우저 저장소(Browser Storage)는 웹 브라우저에서 데이터를 저장하는 기능입니다. 이 기능을 사용하면 브라우저를 닫았다가 다시 열어도 데이터를 유지할 수 있습니다. 대표적인 브라우저 저장소에는 쿠키(Cookie), 로컬 스토리지(Local Storage), 세션 스토리지(Session Storage) 등이 있습니다.

1. **쿠키(Cookie) :** 
- 만료 기한이 있는 키-값 저장소이다.
- 4KB까지 데이터 저장 가능
- 서버와 클라이언트 간의 상태 정보를 유지하기 위해 사용되는 작은 데이터 파일
- 쿠키는 브라우저에 저장되며, 웹사이트에서 쿠키를 읽거나 쓸 수 있다.
- 쿠키는 주로 로그인 정보나 사용자 환경 설정 등을 저장하는 데 사용됩니다.

1. **로컬 스토리지(Local Storage) :** 
- 만료기한이 없는 브라우저 내에 키-값 쌍 저장소. 10MB까지 저장가능.
- 로컬 스토리지는 브라우저를 닫았다가 다시 열어도 데이터유지
- 로컬 스토리지는 쿠키보다 용량이 크고, 서버에 전송되지 않으므로 보안성이 높다.

1. **세션 스토리지(Session Storage)** :
- 로컬 스토리지와 비슷하지만, 세션이 끝나면 저장된 데이터가 삭제.
- 만료기한이 없는 브라우저 내에 키-값 쌍 저장소. 5MB까지 저장가능
- 탭단위로 세션스토리지를 생성, 탭을 닫을때 해당 데이터가 삭제
- 세션 스토리지는 보통 로그인 정보 등을 저장하는 데 사용됩니다.

브라우저 저장소는 브라우저를 닫았다가 다시 열어도 데이터를 유지할 수 있기 때문에, 사용자 경험을 개선하고 빠르고 효율적인 웹 애플리케이션을 만드는 데 도움이 됩니다.

### **RESTful API에는 다음과 같은 이점이 있습니다.**

### 확장성

REST API를 구현하는 시스템은 REST가 클라이언트-서버 상호 작용을 최적화하기 때문에 효율적으로 크기 조정할 수 있습니다. 무상태는 서버가 과거 클라이언트 요청 정보를 유지할 필요가 없기 때문에 서버 로드를 제거합니다. 잘 관리된 캐싱은 일부 클라이언트-서버 상호 작용을 부분적으로 또는 완전히 제거합니다. 이러한 모든 기능은 성능을 저하시키는 통신 병목 현상을 일으키지 않으면서 확장성을 지원합니다.

### 유연성

RESTful 웹 서비스는 완전한 클라이언트-서버 분리를 지원합니다. 각 부분이 독립적으로 발전할 수 있도록 다양한 서버 구성 요소를 단순화하고 분리합니다. 서버 애플리케이션의 플랫폼 또는 기술 변경은 클라이언트 애플리케이션에 영향을 주지 않습니다. 애플리케이션 함수를 계층화하는 기능은 유연성을 더욱 향상시킵니다. 예를 들어, 개발자는 애플리케이션 로직을 다시 작성하지 않고도 데이터베이스 계층을 변경할 수 있습니다.

### 독립성

REST API는 사용되는 기술과 독립적입니다. API 설계에 영향을 주지 않고 다양한 프로그래밍 언어로 클라이언트 및 서버 애플리케이션을 모두 작성할 수 있습니다. 또한 통신에 영향을 주지 않고 양쪽의 기본 기술을 변경할 수 있습니다.

RESTful API에서 자원(Resource)은 URI(Uniform Resource Identifier)로 표현되며, HTTP 메서드(GET, POST, PUT, DELETE)를 사용하여 CRUD 기능을 수행합니다. 각각의 HTTP 메서드는 자원에 대한 다음과 같은 작업을 수행합니다.

- GET: 자원을 조회합니다.
- POST: 새로운 자원을 생성합니다.
- PUT: 기존 자원을 수정합니다.
- DELETE: 자원을 삭제합니다.

### **REST의 장단점**

장점

- HTTP 프로토콜의 인프라를 그대로 사용하므로 REST API 사용을 위한 별도의 인프라를 구출할 필요가 없다.
- HTTP 프로토콜의 표준을 최대한 활용하여 여러 추가적인 장점을 함께 가져갈 수 있게 해 준다.
- HTTP 표준 프로토콜에 따르는 모든 플랫폼에서 사용이 가능하다.
- Hypermedia API의 기본을 충실히 지키면서 범용성을 보장한다.
- REST API 메시지가 의도하는 바를 명확하게 나타내므로 의도하는 바를 쉽게 파악할 수 있다.
- 여러 가지 서비스 디자인에서 생길 수 있는 문제를 최소화한다.
- 서버와 클라이언트의 역할을 명확하게 분리한다.

단점

- 표준이 자체가 존재하지 않아 정의가 필요하다.
- HTTP Method 형태가 제한적이다.
- 브라우저를 통해 테스트할 일이 많은 서비스라면 쉽게 고칠 수 있는 URL보다 Header 정보의 값을 처리해야 하므로 전문성이 요구된다.
- 구형 브라우저에서 호환이 되지 않아 지원해주지 못하는 동작이 많다.(익스폴로어)


## 불변성을 유지하려면 어떻게 해야 하나요?
객체를 const로 선언합니다.
객체의 속성에 setter 메서드를 사용하지 않습니다.
Immutable.js와 같은 불변 라이브러리를 사용합니다.
객체를 const로 선언하면 객체의 값을 변경할 수 없습니다. setter 메서드는 객체의 속성을 변경하는 데 사용되는 메서드입니다. setter 메서드를 사용하지 않으면 객체의 값을 변경할 수 없습니다. Immutable.js는 불변 자료구조를 제공하는 라이브러리입니다. Immutable.js를 사용하면 불변 자료구조를 쉽게 사용할 수 있습니다.

불변성을 유지하면 다음과 같은 이점이 있습니다.

코드가 간결하고 이해하기 쉽습니다.
버그 발생 가능성이 줄어듭니다.
성능이 향상됩니다.
불변성은 자바스크립트에서 중요한 개념입니다. 불변성을 유지하면 코드의 품질을 향상시킬 수 있습니다.
## 깊은 복사와 얕은 복사에 대해 설명해 주세요.
1. 얕은 복사(Shallow Copy):
    - 얕은 복사는 원본 객체나 배열의 참조(reference)를 복사합니다.
    - 복사된 객체나 배열은 원본과 동일한 참조를 가리키기 때문에 원본의 변경이 복사본에 영향을 미칠 수 있습니다.
    - 얕은 복사는 주로 단순한 데이터 구조에서 사용됩니다.
    - JavaScript에서는 **`Object.assign()`** 메서드나 전개 연산자(**`...`**)를 사용하여 얕은 복사를 수행할 수 있습니다.
2. 깊은 복사(Deep Copy):
    - 깊은 복사는 원본 객체나 배열의 값 자체를 재귀적으로 복사합니다.
    - 복사된 객체나 배열은 완전히 독립적인 복사본이므로 원본의 변경이 복사본에 영향을 미치지 않습니다.
    - 중첩된 객체나 배열이 많거나, 원본과 복사본을 분리하여 독립적으로 사용해야 할 때 유용합니다.
    - JavaScript에서는 JSON.stringify()와 JSON.parse()를 조합하여 깊은 복사를 수행할 수 있습니다. 또는 라이브러리인 Lodash나 Immutable.js와 같은 도구를 사용할 수도 있습니다
## 프론트엔드 빌드 시스템에 대해서 설명해 주세요.
## CSR 과 SSR의 차이를 설명해주세요.
렌더링이 클라이언트 쪽에서 일어난다.즉, 서버는 요청을 받으면 클라이언트에 HTML과 JS를 보내준다.

![image](https://github.com/theo-jin/CsAndBooks/assets/83561523/34adbad0-4b8e-40f0-91c0-0eaa54a29cfc)

1.  User가 Website 요청을 보냄.

2. CDN이 HTML 파일과 JS로 접근할 수 있는 링크를 클라이언트로 보낸다.

CDN : aws의 cloudflare를 생각하면 됨. 엔드 유저의 요청에 '물리적'으로 가까운 서버에서 요청에 응답하는 방식

3. 클라이언트는 HTML과 JS를 다운로드 받는다.(**이때 SSR과 달리 유저는 아무것도 볼 수 없다**

.)

4. 브라우저가 자바스크립트를 다운받음.

5. 다운이 완료된 JS가 실행된다. 데이터를 위한 API가 호출된다.

(이때 유저들은 placeholder를 보게된다. )

6. 서버가 API로부터의 요청에 응답한다.

7. API로부터 받아온 data를 placeholder 자리에 넣어준다. 이제 페이지는 상호작용이 가능해진다.

클라이언트는 그것을 받아 렌더링을 시작한다.
## 세션 기반 인증과 토큰 기반 인증에 대해 설명해 주세요.

**인증(Autenticaion)**: 유저가 누구인지 확인하는 절차

• 특정 서비스에 일정 권한이 주어진 사용자임을 아이디와 패스워드를 통해 인증 받는 것

**인가(Authorization)**: 유저의 요청에 대한 권한을 확인하고 허가 해주는 것

- 인가를 하기 위해서는 반드시 인증이 선행되어야한다!
- 내 계정으로’만’ 할 수 있는 활동을 시도할 때 허가 해주는 것
