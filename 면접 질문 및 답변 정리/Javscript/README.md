# Javscript
### Webpack, Babel, Polyfill에 대해 설명해주세요
Webpack, Babel, 그리고 Polyfill은 모두 JavaScript 프로젝트를 개발하고 배포하는 데 사용되는 도구들입니다.

Webpack은 JavaScript 애플리케이션의 모듈 번들러로, 여러 개의 JavaScript 파일을 하나의 파일로 묶어주는 역할을 합니다. 
이로써 파일 간의 의존성을 관리하고, 각 파일에서 사용되는 라이브러리나 모듈들을 최적화하여 하나의 번들 파일로 생성하여 로딩 시간을 줄일 수 있습니다.

Babel은 ES6+와 같은 최신 버전의 JavaScript 문법을 이전 버전의 브라우저에서도 호환 가능한 코드로 변환해주는 트랜스파일러입니다. 
이를 통해 개발자들은 최신 기술을 사용하면서도 모든 브라우저에서 동작 가능한 코드를 생성할 수 있습니다.

Polyfill은 브라우저에서 지원하지 않는 JavaScript 기능을 구현하는 코드로, 브라우저 호환성을 보장하기 위해 사용됩니다. 
즉, Polyfill은 특정 브라우저에서 지원하지 않는 ES6+의 새로운 기능을 구현하여 해당 기능을 사용할 수 있도록 해줍니다.

따라서, 이 세 가지 도구는 모두 최신 기술을 사용하여 JavaScript 애플리케이션을 개발하면서, 모든 브라우저에서 호환 가능한 코드를 생성하고,
이를 최적화하여 로딩 시간을 단축시키는 역할을 합니다

### Promise와 Callback 차이를 설명해주세요
Promise와 Callback은 모두 비동기 프로그래밍에서 사용되는 개념이지만, 사용 방법과 동작 방식에 차이가 있습니다.

Callback은 어떤 이벤트가 발생하면 실행되는 함수를 말합니다. 이벤트가 발생하면 해당 콜백 함수가 호출되고, 이후에 다음 코드가 실행됩니다. 콜백 함수는 보통 함수의 인자로 전달되어 사용됩니다. 콜백 함수를 중첩하여 사용하면 콜백지옥(callback hell)이라는 코드의 가독성과 유지보수를 어렵게 만드는 문제가 발생할 수 있습니다.

반면 Promise는 비동기 작업을 나타내는 객체입니다. Promise 객체는 처음에는 비동기 작업이 수행되지 않고 대기 상태가 됩니다. 이후 비동기 작업이 성공하면 resolve 콜백 함수가 호출되고, 실패하면 reject 콜백 함수가 호출됩니다. 이렇게 호출된 콜백 함수에 따라서 Promise의 상태가 결정됩니다. Promise 객체를 반환하는 함수는 then() 메서드를 사용하여 성공 시 처리할 로직을 작성하거나 catch() 메서드를 사용하여 실패 시 처리할 로직을 작성할 수 있습니다.

이러한 차이점으로 보면, Callback은 함수 인자를 통해 다음 로직을 처리하고, Promise는 객체를 통해 상태를 반환하며 다음 로직을 처리합니다. 따라서 Promise는 콜백지옥 문제를 해결할 수 있고, 더 직관적이며 유지보수하기 쉬운 코드를 작성할 수 있습니다.

### 콜백지옥은 무엇인가요
콜백지옥(callback hell)은 비동기 프로그래밍에서 발생하는 문제로, 콜백 함수를 연속적으로 호출하여 코드의 가독성을 해치고 유지보수를 어렵게 만드는 상황을 말합니다.

콜백(callback)은 비동기 프로그래밍에서 자주 사용되는 개념으로, 어떤 이벤트가 발생할 때 실행되는 함수를 말합니다. 이벤트가 발생하면 해당 함수가 호출되고, 이후에 다음 코드가 실행됩니다. 이때 이벤트 처리가 끝나기 전에 다음 코드가 실행되는 비동기적 특성 때문에 콜백 함수를 여러 번 중첩하여 사용하게 되면 코드의 가독성과 유지보수가 어렵게 됩니다. 이러한 중첩된 콜백 함수의 구조가 마치 지옥과 같이 깊게 들어간 구조로 보이기 때문에 콜백지옥이라고 부릅니다.

콜백지옥을 해결하기 위해서는 Promise, async/await과 같은 비동기 처리 방법을 사용하거나, 코드를 구조화하는 방법 등이 있습니다.

### 이벤트 버블링과 캡처링에 대해 설명해주세요

이벤트 버블링(Event Bubbling)과 이벤트 캡처링(Event Capturing)은 HTML 요소에서 발생한 이벤트가 상위 요소로 전파되는 방식에 대한 개념입니다.

이벤트 버블링은 하위 요소에서 이벤트가 발생하면 해당 요소에서 상위 요소로 이벤트가 전파되는 방식을 말합니다. 즉, 하위 요소에서 이벤트가 발생했을 때 해당 요소에서 이벤트 핸들러가 호출되고, 이후에 상위 요소로 이벤트가 전파되면서 상위 요소의 이벤트 핸들러도 호출됩니다. 이러한 방식은 기본적으로 모든 HTML 요소에 적용되며, 대부분의 경우 이벤트 버블링 방식이 적합합니다.

반면 이벤트 캡처링은 상위 요소에서 하위 요소로 이벤트가 전파되는 방식입니다. 즉, 상위 요소에서 이벤트가 발생했을 때 해당 요소에서 이벤트 핸들러가 호출되고, 이후에 하위 요소로 이벤트가 전파되면서 하위 요소의 이벤트 핸들러도 호출됩니다. 이벤트 캡처링 방식은 기본적으로 적용되지 않으며, 이벤트 버블링 방식과 함께 사용하면서 더욱 복잡한 이벤트 처리를 구현할 수 있습니다.

이벤트 버블링과 이벤트 캡처링을 모두 사용하면서 이벤트 전파를 제어할 수 있는 메서드로는 stopPropagation()이 있습니다. 이 메서드는 이벤트가 전파되는 것을 막아줍니다. 이외에도 preventDefault() 메서드를 사용하여 이벤트의 기본 동작을 막을 수 있습니다.


### forEach 메서드와 map메서드의 차이점에 대해 알고 있나요?
forEach()와 map() 메서드는 배열을 순회하며 각 요소에 접근하여 처리하는 데 사용됩니다. 그러나 두 메서드는 목적과 반환값이 다르며 차이점이 있습니다.
forEach() 메서드는 주어진 함수를 배열의 각 요소마다 한 번씩 실행합니다. 이 메서드는 원본 배열을 변경하지 않으며, 반환값이 없습니다. forEach() 메서드는 주로 배열의 각 요소에 대해 작업을 수행하고자 할 때 사용됩니다.

```
const arr=[1,2,3];
arr.forEach((item,index)=>{
console.log(`${index}:${item)`);
});
//출력결과
//0:1
//1:2
//2:3
```

map() 메서드는 주어진 함수를 배열의 각 요소마다 호출하여, 각 요소를 처리한 결과를 새로운 배열로 반환합니다. map() 메서드는 원본 배열을 변경하지 않으며, 새로운 배열을 반환합니다. map() 메서드는 주로 배열의 각 요소를 가공하여 새로운 배열을 생성하고자 할 때 사용됩니다.

```
const arr = [1, 2, 3];

const newArr = arr.map(item => item * 2);

console.log(newArr); // [2, 4, 6]
```

따라서, forEach()와 map() 메서드는 모두 배열의 요소를 순회하며 작업을 수행하는 데 사용됩니다. 그러나 forEach()는 주어진 함수를 호출하고 아무것도 반환하지 않으며, map()은 주어진 함수를 호출한 결과를 새로운 배열로 반환합니다.
