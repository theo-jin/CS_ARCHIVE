# Javscript
### Webpack, Babel, Polyfill에 대해 설명해주세요
Webpack, Babel, 그리고 Polyfill은 모두 JavaScript 프로젝트를 개발하고 배포하는 데 사용되는 도구들입니다.

Webpack은 JavaScript 애플리케이션의 모듈 번들러로, 여러 개의 JavaScript 파일을 하나의 파일로 묶어주는 역할을 합니다. 
이로써 파일 간의 의존성을 관리하고, 각 파일에서 사용되는 라이브러리나 모듈들을 최적화하여 하나의 번들 파일로 생성하여 로딩 시간을 줄일 수 있습니다.

Babel은 ES6+와 같은 최신 버전의 JavaScript 문법을 이전 버전의 브라우저에서도 호환 가능한 코드로 변환해주는 트랜스파일러입니다. 
이를 통해 개발자들은 최신 기술을 사용하면서도 모든 브라우저에서 동작 가능한 코드를 생성할 수 있습니다.

Polyfill은 브라우저에서 지원하지 않는 JavaScript 기능을 구현하는 코드로, 브라우저 호환성을 보장하기 위해 사용됩니다. 
즉, Polyfill은 특정 브라우저에서 지원하지 않는 ES6+의 새로운 기능을 구현하여 해당 기능을 사용할 수 있도록 해줍니다.

따라서, 이 세 가지 도구는 모두 최신 기술을 사용하여 JavaScript 애플리케이션을 개발하면서, 모든 브라우저에서 호환 가능한 코드를 생성하고,
이를 최적화하여 로딩 시간을 단축시키는 역할을 합니다

### 웹팩이 등장한 이유, 웹팩 사용 시 이점,왜 웹팩을 사용하는가?

Webpack은 JavaScript 애플리케이션에서 모듈 번들링을 제공하는 도구로 등장했습니다. 이전에는 JavaScript 애플리케이션을 작성할 때, 다수의 파일을 로드하는 것이 일반적이었습니다. 이는 애플리케이션의 규모가 커질수록 파일의 로딩 시간이 길어지고, 관리가 어려워지는 문제가 있었습니다.

Webpack은 이러한 문제를 해결하기 위해 다수의 파일을 하나의 파일로 묶어주는 기능을 제공합니다. 또한, CSS, 이미지, 폰트 등의 리소스도 번들링하여 애플리케이션 로딩 시간을 단축할 수 있습니다.

웹팩을 사용하면 여러 가지 이점이 있습니다. 먼저, 애플리케이션의 구조가 모듈 단위로 분리되므로 코드의 가독성과 유지보수성이 향상됩니다. 또한, 모듈간의 의존성 관리가 용이해지므로 개발자는 코드를 더욱 쉽게 작성할 수 있습니다.

또한, 웹팩은 다양한 로더와 플러그인을 지원하여 개발자가 원하는 기능을 추가할 수 있습니다. 예를 들어, SASS나 LESS와 같은 CSS 전처리기를 사용할 수 있고, Babel과 같은 트랜스파일러를 이용하여 최신 JavaScript 문법을 사용할 수 있습니다.

마지막으로, 웹팩은 개발과 배포를 구분하여 처리할 수 있습니다. 개발 모드에서는 코드를 번들링하고 모니터링할 수 있고, 배포 모드에서는 코드를 최적화하여 성능을 향상시킬 수 있습니다.
따라서, 웹팩은 모듈 번들링을 통해 애플리케이션의 성능과 유지보수성을 개선하는 데 큰 역할을 합니다. 이러한 이유로 웹팩을 사용하여 JavaScript 애플리케이션을 개발하는 것이 일반적입니다.


### Promise와 Callback 차이를 설명해주세요
Promise와 Callback은 모두 비동기 프로그래밍에서 사용되는 개념이지만, 사용 방법과 동작 방식에 차이가 있습니다.

Callback은 어떤 이벤트가 발생하면 실행되는 함수를 말합니다. 이벤트가 발생하면 해당 콜백 함수가 호출되고, 이후에 다음 코드가 실행됩니다. 콜백 함수는 보통 함수의 인자로 전달되어 사용됩니다. 콜백 함수를 중첩하여 사용하면 콜백지옥(callback hell)이라는 코드의 가독성과 유지보수를 어렵게 만드는 문제가 발생할 수 있습니다.

반면 Promise는 비동기 작업을 나타내는 객체입니다. Promise 객체는 처음에는 비동기 작업이 수행되지 않고 대기 상태가 됩니다. 이후 비동기 작업이 성공하면 resolve 콜백 함수가 호출되고, 실패하면 reject 콜백 함수가 호출됩니다. 이렇게 호출된 콜백 함수에 따라서 Promise의 상태가 결정됩니다. Promise 객체를 반환하는 함수는 then() 메서드를 사용하여 성공 시 처리할 로직을 작성하거나 catch() 메서드를 사용하여 실패 시 처리할 로직을 작성할 수 있습니다.

이러한 차이점으로 보면, Callback은 함수 인자를 통해 다음 로직을 처리하고, Promise는 객체를 통해 상태를 반환하며 다음 로직을 처리합니다. 따라서 Promise는 콜백지옥 문제를 해결할 수 있고, 더 직관적이며 유지보수하기 쉬운 코드를 작성할 수 있습니다.

### 콜백지옥은 무엇인가요
콜백지옥(callback hell)은 비동기 프로그래밍에서 발생하는 문제로, 콜백 함수를 연속적으로 호출하여 코드의 가독성을 해치고 유지보수를 어렵게 만드는 상황을 말합니다.

콜백(callback)은 비동기 프로그래밍에서 자주 사용되는 개념으로, 어떤 이벤트가 발생할 때 실행되는 함수를 말합니다. 이벤트가 발생하면 해당 함수가 호출되고, 이후에 다음 코드가 실행됩니다. 이때 이벤트 처리가 끝나기 전에 다음 코드가 실행되는 비동기적 특성 때문에 콜백 함수를 여러 번 중첩하여 사용하게 되면 코드의 가독성과 유지보수가 어렵게 됩니다. 이러한 중첩된 콜백 함수의 구조가 마치 지옥과 같이 깊게 들어간 구조로 보이기 때문에 콜백지옥이라고 부릅니다.

콜백지옥을 해결하기 위해서는 Promise, async/await과 같은 비동기 처리 방법을 사용하거나, 코드를 구조화하는 방법 등이 있습니다.

### 이벤트 버블링과 캡처링에 대해 설명해주세요

이벤트 버블링(Event Bubbling)과 이벤트 캡처링(Event Capturing)은 HTML 요소에서 발생한 이벤트가 상위 요소로 전파되는 방식에 대한 개념입니다.

이벤트 버블링은 하위 요소에서 이벤트가 발생하면 해당 요소에서 상위 요소로 이벤트가 전파되는 방식을 말합니다. 즉, 하위 요소에서 이벤트가 발생했을 때 해당 요소에서 이벤트 핸들러가 호출되고, 이후에 상위 요소로 이벤트가 전파되면서 상위 요소의 이벤트 핸들러도 호출됩니다. 이러한 방식은 기본적으로 모든 HTML 요소에 적용되며, 대부분의 경우 이벤트 버블링 방식이 적합합니다.

반면 이벤트 캡처링은 상위 요소에서 하위 요소로 이벤트가 전파되는 방식입니다. 즉, 상위 요소에서 이벤트가 발생했을 때 해당 요소에서 이벤트 핸들러가 호출되고, 이후에 하위 요소로 이벤트가 전파되면서 하위 요소의 이벤트 핸들러도 호출됩니다. 이벤트 캡처링 방식은 기본적으로 적용되지 않으며, 이벤트 버블링 방식과 함께 사용하면서 더욱 복잡한 이벤트 처리를 구현할 수 있습니다.

이벤트 버블링과 이벤트 캡처링을 모두 사용하면서 이벤트 전파를 제어할 수 있는 메서드로는 stopPropagation()이 있습니다. 이 메서드는 이벤트가 전파되는 것을 막아줍니다. 이외에도 preventDefault() 메서드를 사용하여 이벤트의 기본 동작을 막을 수 있습니다.


### forEach 메서드와 map메서드의 차이점에 대해 알고 있나요?
forEach()와 map() 메서드는 배열을 순회하며 각 요소에 접근하여 처리하는 데 사용됩니다. 그러나 두 메서드는 목적과 반환값이 다르며 차이점이 있습니다.
forEach() 메서드는 주어진 함수를 배열의 각 요소마다 한 번씩 실행합니다. 이 메서드는 원본 배열을 변경하지 않으며, 반환값이 없습니다. forEach() 메서드는 주로 배열의 각 요소에 대해 작업을 수행하고자 할 때 사용됩니다.

```
const arr=[1,2,3];
arr.forEach((item,index)=>{
console.log(`${index}:${item)`);
});
//출력결과
//0:1
//1:2
//2:3
```

map() 메서드는 주어진 함수를 배열의 각 요소마다 호출하여, 각 요소를 처리한 결과를 새로운 배열로 반환합니다. map() 메서드는 원본 배열을 변경하지 않으며, 새로운 배열을 반환합니다. map() 메서드는 주로 배열의 각 요소를 가공하여 새로운 배열을 생성하고자 할 때 사용됩니다.

```
const arr = [1, 2, 3];

const newArr = arr.map(item => item * 2);

console.log(newArr); // [2, 4, 6]
```

따라서, forEach()와 map() 메서드는 모두 배열의 요소를 순회하며 작업을 수행하는 데 사용됩니다. 그러나 forEach()는 주어진 함수를 호출하고 아무것도 반환하지 않으며, map()은 주어진 함수를 호출한 결과를 새로운 배열로 반환합니다.




### 얕은 복사(Shallow Copy)
• 객체를 복사할 때, 해당 객체만 복사하여 새 객체를 생성한다.

•	복사된 객체의 인스턴스 변수는 원본 객체의 인스턴스 변수와 같은 메모리 주소를 참조한다.

•	따라서, 해당 메모리 주소의 값이 변경되면 원본 객체 및 복사 객체의 인스턴스 변수 값은 같이 변경된다.

### 깊은 복사(Deep Copy)

•	객체를 복사 할 때, 해당 객체와 인스턴스 변수까지 복사하는 방식.

•	전부를 복사하여 새 주소에 담기 때문에 참조를 공유하지 않는

### 뮤터블 vs 이뮤터블
Mutable한 객체는 생성된 이후에 상태가 변경될 수 있는 객체이고, Immutable한 객체는 생성된 이후에 상태가 변경되지 않는 객체를 말한다. 자바스크립트에서 Object와 Array를 제외한 모든 타입은 Immutable한 타입이다.

### apply, call, bind의 차이는 무엇인가요?
Call 메서드는 모든 함수에서 사용할 수 있으며, this를 특정값으로 지정할 수 있다.
Apply는 함수 매개변수를 처리하는 방법을 제외하면 call과 유사함. Call은 일반적인 함수와 마찬가지로 파라미터를 직접 밪디만, apply는 매개변수를 배열로 받는다. 
### 식별자란 무엇인가요? 
변수이름을 식별자라고 한다. 식별자는 어떤 값을 구별해서 식별할수 있는 고유한 이름을 뜻함.
### 클로저가 무엇인가요 
클로저는 자신이 생성될 때의 환경(Lexical environment)을 기억하는 함수다 클로저는 반환된 내부함수가 자신이 선언됐을 때의 환경(Lexical environment)인 스코프를 기억하여 자신이 선언됐을 때의 환경(스코프) 밖에서 호출되어도 그 환경(스코프)에 접근할 수 있는 함수
### TDZ는 무엇인가요?

### var, let, const의 차이는 무엇인가요?
Var : 중복 선언 가능
let : 중복 선언 불가능, 재할당 가능
const : 중복 선언 불가능, 재할당 불가능

### 스코프에 대해 설명해주세요
**스코프는 참조 대상 식별자(identifier, 변수, 함수의 이름과 같이 어떤 대상을 다른 대상과 구분하여 식별할 수 있는 유일한 이름)를 찾아내기 위한 규칙.**

식별자는 자신이 어디에서 선언됐는지에 의해 자신이 유효한(다른 코드가 자신을 참조할 수 있는) 범위를 갖는다.

자바스크립트에서 스코프를 구분해보면 다음과 같이 2가지로 나눌 수 있다.

**전역 스코프 (Global scope)**
코드 어디에서든지 참조할 수 있다.

**지역 스코프 (Local scope or Function-level scope)**
함수 코드 블록이 만든 스코프로 함수 자신과 하위 함수에서만 참조할 수 있다.


### 프로토 타입 객체
Javascript에서는 객체를 상속하기 위하여 프로토타입이라는 방식을 사용한다. 모든 객체들이 메소드와 속성들을 상속 받기 위해서 프로토타입 객체(prototype object)를 가진다.

이 프로토타입은 __proto__라는 내부 속성을 통해 접근할 수 있습니다. 객체를 생성할 때 해당 객체의 프로토타입을 지정하거나 기본적으로 자바스크립트에서 제공하는 Object 프로토타입을 상속받게 됩니다.

이러한 프로토타입 객체도 또 다시 상위 프로토타입 객체로부터 메소드와 속성을 상속 받을 수도 있고 그 상위 프로토타입 객체도 마찬가지입니다. 이를 프로토타입 체인(prototype chain)이라 부르며 다른 객체에 정의된 메소드와 속성을 한 객체에서 사용할 수 있도록 합니다. 

더 정확히는 자바스크립트는 특정 객체의 프로퍼티나 메소드에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티 또는 메소드가 없다면 [[Prototype]]이 가리키는 링크를 따라 자신의 부모 역할을 하는 프로토타입 객체의 프로퍼티나 메소드를 차례대로 검색한다. 이것을 프로토타입 체인이라 한다.

상속되는 속성과 메소드들은 각 객체가 아니라 객체의 생성자의 prototype이라는 속성에 정의되어 있습니다.
JavaScript에서는 객체 인스턴스와 프로토타입 간에 연결이 구성되며 이 연결을 따라 프로토타입 체인을 타고 올라가며 속성과 메소드를 탐색합니다. 
(많은 브라우저들이 생성자의 prototype 속성에서 파생된 __proto__ 속성으로 객체 인스턴스에 구현하고 있습니다.)
프로토타입을 사용하여 객체를 상속하는 방법 중 하나는 생성자 함수(Constructor Function)를 활용하는 것입니다. 생성자 함수를 사용하여 객체를 생성하면 해당 객체는 생성자 함수의 프로토타입을 상속받습니다.

### nodejs와 그냥 js의 차이점은 무엇인가요?
JavaScript는 독립적인 언어가 아니라 스크립트 언어로써, 특정한 프로그램 안에서만 동작을 할 수 있고, 웹 브라우저가 없으면 사용할 수 없는 단점이 공존했다. 따라서 client개발을 위한 용도로만 국한되어 있었다.
Node/js는 터미널 프로그램(원도우 cmd, mac terminal 등)에서 브라우저 없이도 실행할 수 있게 됐다.
JavaScript를 크롬(Chrome)같은 브라우저에서만 쓰는 것이 아닌 브라우저 밖. 즉, 내 컴퓨터에서 다양한 용도로 확장하기 위해 만들어진 것이 바로 Node.js이다. Node.js를 이용하면 Python과 같이 내 컴퓨터에서 File System를 이용할 수 있고, 서버를 만들 수도 있고 크롤링도 할 수 있습니다. 
Node.js를 이용하여 Express같은 라이브러리를 이용해서 서버를 만들곤하지만, Node.js 자체는 웹서버가 아니다. 위에 말씀드렸다싶이 Node.js는 자바스크립트 런타임(JavaScript Runtime)으로 Node.js는 웹 서버를 만들 수 있는 하나의 방법에 불과하다.
 
크롬(Chrome)과 Node.js는 따라서 같은 엔진(Google의 V8 엔진)을 공유하지만, 다른 런타임(runtime) 환경, 즉 크롬(Chrome)과 Node.js라는 다른 실행 환경을 가지고 있다고 할 수 있다.
