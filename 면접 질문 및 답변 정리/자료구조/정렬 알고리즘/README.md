# 정렬 알고리즘
```
거품 정렬(Bubble Sort)
선택 정렬(Selection Sort)
삽입 정렬(Insertion Sort)
퀵 정렬(Quick Sort)
병합 정렬(Merge Sort)
힙 정렬(Heap Sort)
계수 정렬(Counting Sort)
기수 정렬(Radix sort)
```
### Stable 정렬
정렬을 했을 때 중복된 값들의 순서가 변하지 않는 것을 말합니다.

만약, arr = [1, 7(1), 3, 5, 4, 7(2), 9] 을 정렬한 결과는
```
arr = [1, 3, 4, 5, 7(1), 7(2), 9] 이면 Stable(안정)
arr = [1, 3, 4, 5, 7(2), 7(1), 9] 이면 Unstable(불안정)
```
 
### In-place 정렬
정렬하는데 추가적인 메모리 공간이 거의 들지 않는 것을 말합니다.
제자리 정렬이라고도 합니다.

## 버블 정렬(Bubble Sort)
버블정렬은 이웃한  두원소의 대소관계를 비교하여 필요에 따라 교환을 반복하는 알고리즘. 단순교환 정렬이라고도한다. 

- i번째 원소와 i+1번째 원소의 값을 비교하고 만약 i번째의 값이 i+1번째의 값보다 크다면 둘의 자리를 바꾸어 값이 큰 원소가 뒤에 위치하게 합니다.
- 이를 반복해서 수행하면 가장 큰 값부터 뒤쪽에 쌓이게 되겠죠.
- 즉 가장 큰값을 하나씩 뒤로 보내면서 뒤쪽부터 정렬하는 것입니다.
시간 복잡도
시간 복잡도를 계산하면, (n-1) + (n-2) + (n-3) + .... + 2 + 1 = n(n-1) / 2 이므로 O(n^2) 
## 선택 정렬(Selection Sort)
선택 정렬은 앞쪽부터 정렬하는 방식입니다.

주어진 배열에서 가장 작은 최소값을 찾고 배열의 맨 앞의 값과 위치를 바꾸면서 정렬합니다.
맨 앞의 값을 제외한 배열로 다시 반복합니다.
 

선택 정렬은 배열의 최솟값을 찾아 선택하여 정렬한다는 뜻에서 이름이 붙여졌습니다. 배열에서 최솟값을 찾아야 하기 때문에 비교 횟수는 많지만 실제로 값을 바꾸는 교환 횟수가 적다는 것이 특징입니다

 
```ts
function selectionSort(arr) {
  let indexMin;
  for (let x = 0; x < arr.length - 1; x++) {
    indexMin = x;
    for (let y = x + 1; y < arr.length; y++) {
      if (arr[y] < arr[indexMin]) {
        indexMin = y;
      }
    }
    [arr[x], arr[indexMin]] = [arr[indexMin], arr[x]];
  }
  return arr;
}
```

⏱ 시간 복잡도
(n-1) + (n-2) + .... + 2 + 1 = n(n-1) / 2 이므로 시간 복잡도는 O(n^2) 입니다.
최선, 평균, 최악의 경우 모두 시간복잡도가 O(n^2) 으로 동일합니다.
 
👍 장점
버블 정렬과 마찬가지로 구현이 간단합니다.
비교하는 횟수에 비해 교환하는 횟수가 적기 때문에, 많은 교환이 일어나야 하는 자료 상태에서 비교적 효율적입니다.
정렬하고자 하는 배열 안에서 교환하는 방식이므로 In-place 정렬입니다.
 

👎 단점
데이터를 하나씩 비교하기 때문에 시간복잡도가 O(n^2)으로, 비효율적입니다.
Unstable 정렬입니다. (구현하는 방식에 따라 달라질 수 있음)
정렬된 상태에서 새로운 데이터가 추가되면 정렬 효율이 좋지 않습니다.
### 양방향 버블 정렬

버블 정렬과는 달리 매 반복마다 배열의 순서를 바꾸어 정렬합니다.
홀수 번째 반복은 가장 작은 요소를 맨 앞으로, 짝수 번째 반복은 가장 큰 요소를 맨 뒤로 정렬합니다. (또는 반대)
시간복잡도는 최선의 경우 O(n)을 만족합니다!
평균과 최악의 경우 여전히 O(n^2) 입니다..

## 삽입 정렬(Insertion Sort)
- 삽입 정렬은 버블 정렬의 비효율성을 개선하기 위해 등장한 방법
- 버블 정렬은 i번째와 i+1번째를 비교하며 위치를 바꾸었다면, 삽입 정렬은 i번째 원소를 정렬된 상태의 앞부분과 비교하여 적절한 위치에 삽입하는 방식.

- i-1번째 원소까지는 모두 정렬된 상태여야 하며 i-1번째부터 0번째까지의 원소와 i번째 원소를 각각 비교.
이때 i번째 원소보다 작은 값이 발견되면 그 위치에 i번째 원소를 삽입합니다.
 

삽입 정렬은 버블 정렬의 비교 및 교환 횟수를 줄임으로써 높은 효율을 보여줍니다.

 
```ts
function insertionSort(arr) {
  for (let x = 1; x < arr.length; x++) {
    let value = arr[x];
    let prev = x - 1;
    while (prev >= 0 && arr[prev] > value) {
      arr[prev + 1] = arr[prev];
      prev--;
    }
    arr[prev + 1] = value;
  }

  return arr;
}
``` 
⏱ 시간 복잡도
최악의 경우(역으로 정렬되어 있을 경우), (n-1) + (n-2) + .... + 2 + 1 = n(n-1 )/ 2 으로 O(n^2) 입니다.
하지만 모두 정렬이 되어있는 경우, 한번씩 밖에 비교를 안하므로 O(n) 의 시간복잡도를 가지게 됩니다.
즉, 최선의 경우 = O(n), 평균과 최악의 경우 = O(n^2) 입니다.
 

👍 장점
입력으로 들어오는 배열의 원소가 정렬되어있을수록 속도가 빠릅니다.
정렬된 값은 교환이 일어나지 않습니다.
그렇기 때문에, 이미 정렬되어 있는 배열에 자료를 하나씩 삽입/제거하는 경우에는 현실적으로 최고의 정렬 알고리즘이 됩니다.
정렬하고자 하는 배열 안에서 교환하는 방식이므로 In-place 정렬입니다.
Stable 정렬입니다.
선택 정렬, 버블 정렬과 같은 O(n^2) 알고리즘에 비교하여 상대적으로 빠릅니다.
 

👎 단점
평균과 최악의 시간복잡도가 O(n^2)으로 비효율적입니다.
선택 정렬, 버블 정렬과 마찬가지로 배열의 길이가 길어질수록 비효율적입니다.
 

❗️ 선택 정렬과 삽입 정렬을 헷갈리지 마세요!

선택 정렬과 삽입 정렬은 i번째 반복 이후, i 원소가 정렬된 순서로 온다는 점에서 유사합니다.
하지만, 선택 정렬은 i+1번째 원소를 찾기 위해 나머지 모든 원소들을 탐색하지만
삽입 정렬은 i+1번째 원소를 배치하는데 필요한 만큼의 원소만 탐색하기 때문에 훨씬 효율적으로 실행된다는 차이가 있습니다.
## 퀵 정렬(Quick Sort)
## 병합 정렬(Merge Sort)
## 힙 정렬(Heap Sort)
## 계수 정렬(Counting Sort)
계수 정렬은 각 항목을 세어 저장해두고, 이를 앞 순서대로 정렬하는 방식


## Reference
https://east-star.tistory.com/10

