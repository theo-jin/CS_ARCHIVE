HTTP/1 (1996)
TCP 위에 구축되었음
동일한 서버에 대한 모든 요청에는 별도의 TCP 커넥션이 필요하다

HTTP/1.1 (1997)
keep-alive
keep-alive 메커니즘을 이용해 한개 이상의 요청이 진행될 때 커넥션이 재사용될 수 있도록 함
커넥션을 유지하는 것은, 클라이언트가 모든 요청에 대해 TCP three-way handshake를 하지 않아도 됨
따라서 요청 대기 시간을 줄여줌
pipelining
클라이언트가 각 요청에 대한 응답을 기다리기 전에 여러개의 요청을 미리 보낼 수 있음
이때 응답은 요청과 동일한 순서로 수신되어야 함
이는 제대로 구현하기 까다로웠고, 중간에 있는 프록시 서버들이 파이프라이닝을 제대로 처리하지 못함
많은 웹 브라우저에서 지원이 제거 됨
head of line(HOL) blocking
[[HTTP／1 ~ HTTP／ 3|pipelining]]을 사용하면서 발생하는 문제
만약 여러 개의 요청 중 첫 번째 요청이 오랜 시간이 걸리게 된다면, 후속 요청들은 이전 요청이 완료될 때까지 기다려야함
또한 패킷 손실과 같은 이유로 요청이 차단되면, 동일한 연결에 존재하는 모든 후속 요청또한 영향을 받음
multiple TCP connections
성능을 개선하기 위해 브라우저는 일반적으로 동일한 서버에 대해 여러 개의 TCP 연결을 유지 (최대 여섯개)
이를 통해 요청과 응답을 병렬로 전송하고 받아올 수 있음
HTTP/2 (2015)
HTTP stream
단일 TCP 연결에서 여러 요청 스트림을 동일한 서버로 전송함
HTTP/1.1 파이프라이닝과 달리 각 스트림은 서로 독립적이며, 순서대로 보내거나 받을 필요가 없음
head of line blocking
애플리케이션 계층 차원에서에 HOL Blocking 문제를 해결
그렇지만 TCP를 사용하는 트랜스포트 계층에서는 여전히 문제가 존재
push
클라이언트가 따로 polling 할 필요 없이 서버가 새로운 데이터를 사용할 수 있을 때마다 클라이언트에 업데이트를 보낼 수 있음
이진 프로토콜
텍스트 기반 프로토콜이었기 때문에 정보가 아스키 코드로 저장
사람이 읽기에는 편하지만 불필요하게 데이터가 커지는 문제
이 데이터를 바이너리로 변환하여서 효율적으로 데이터를 전송할 수 있게 함
HPACK
달라진 부분만 다시 전송하는 허프만 코딩 기법을 사용
불필요하게 발생하는 오버헤드를 최소화
HTTP/3 (2022)
QUIC
이는 UDP를 기반으로 개발됨
트랜스포트 계층에서 스트림을 일등 시민으로 간주
이 스트림들은 커넥션을 공유하고 있기 때문에, 새로운 스트림을 생성하기 위해 추가적인 handshake가 필요하지 않음
해당 스트림은 독립적으로 전송됨
즉, 한 스트림에 영향을 미치는 패킷 손실이, 다른 스트림에 영향을 미치지 않음
이를 통해 트랜스포트 계층에서의 HOL Blocking 문제 해결
인터넷 사용량이 많은 모바일 환경을 위해 설계되었음
TCP를 사용하면 한 네트워크에서 다른 네트워크로의 연결을 변경하는 handoff 가 느림
QUIC는 커넥션 ID라는 개념을 구현하여, IP 주소와 네트워크 인터페이스 간에 빠르게 커넥션을 전환할 수 있도록 함
이미 웹사이트의 25%에서 사용됨
AWS CloudFront, Nginx 등에서 HTTP/3 을 활성화시킬 수 있음 (NCP, SCP는 HTTP/2까지만 지원함)