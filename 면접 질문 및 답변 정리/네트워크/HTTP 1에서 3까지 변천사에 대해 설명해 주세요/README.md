# HTTP 1에서 3까지 변천사에 대해 설명해 주세요
## HTTP/1 (1996)

한 연결당 하나의 요청을 처리하도록 설계>>> RTT(패킷이 목적지에 도착하고 나서 다시 출발지로 돌아오기까지 걸리는 시간 패킷 왕복시간 )증가
동일한 서버에 대한 모든 요청에는 별도의 TCP 커넥션이 필요
TCP(3-way핸드셰이크) 위에 구축되었음 서버로 부터 파일 가져올때 마다 3웨이 핸드셰이크를 계속 열어야하기 때문에 RTT증가.


## HTTP/1.1 (1997)
HTTP/1.0에서 발전한 것이 바로 HTTP/1.1 매번 TCP연결 하는것이 아니라 한번 TCP초기화를 한 이후에 keep-alive라는 옵션으로 여러개의 파일을 송수신할수 있게 바뀌었다. HTTP/1.0에도 keep-alive가 있었지만 표준화 되어있지 않았고 1.1표준화 되어 기본 옵션으로 설정. 

하지만 한번 TCP 3-웨이 핸드셰이크 발생하면 그다음부터 발생하지 않아 문서 안에 포함된 다수의 리소스를 처리하려면 요청할 리소스 개수에 비례해 대기 시간이 길어지는 단점. 
**keep-alive**  
keep-alive 메커니즘을 이용해 한개 이상의 요청이 진행될 때 커넥션이 재사용될 수 있도록 함  
커넥션을 유지하는 것은, 클라이언트가 모든 요청에 대해 TCP three-way handshake를 하지 않아도 됨
따라서 요청 대기 시간을 줄여줌  

**pipelining**  
클라이언트가 각 요청에 대한 응답을 기다리기 전에 여러개의 요청을 미리 보낼 수 있음
이때 응답은 요청과 동일한 순서로 수신되어야 함
이는 제대로 구현하기 까다로웠고, 중간에 있는 프록시 서버들이 파이프라이닝을 제대로 처리하지 못함
많은 웹 브라우저에서 지원이 제거 됨

**head of line(HOL) blocking**
[[HTTP／1 ~ HTTP／ 3|pipelining]]을 사용하면서 발생하는 문제
만약 여러 개의 요청 중 첫 번째 요청이 오랜 시간이 걸리게 된다면, 후속 요청들은 이전 요청이 완료될 때까지 기다려야함
또한 패킷 손실과 같은 이유로 요청이 차단되면, 동일한 연결에 존재하는 모든 후속 요청또한 영향을 받음

**multiple TCP connections**
성능을 개선하기 위해 브라우저는 일반적으로 동일한 서버에 대해 여러 개의 TCP 연결을 유지 (최대 여섯개)
이를 통해 요청과 응답을 병렬로 전송하고 받아올 수 있음

## HTTP/2 (2015)
HTTP/2는 SPDY프로토콜에서 파생된 HTTP/1.xx보다 지연시간을 줄이고 은답시간을 더 빠르게 할수 있으며 멀티 플렉싱, 헤더압축, 서버푸시, 요청의 우선순위 처리를 지원하는 프로토콜 

**멀티플렉싱** 
여러개의 스트림을 사용하여 송수신한다는 것. 이를 통해 특정 스트림의 패킷이 손실되었다 하더라도 해당 스트림에만 영향 끼치고 나머지 스트림은 동작 가능 >>>HOL문제 해결가능

**HTTP stream**  

단일 TCP 연결에서 여러 요청 스트림을 동일한 서버로 전송함
HTTP/1.1 파이프라이닝과 달리 각 스트림은 서로 독립적이며, 순서대로 보내거나 받을 필요가 없음  

**head of line blocking**  

애플리케이션 계층 차원에서에 HOL Blocking 문제를 해결
그렇지만 TCP를 사용하는 트랜스포트 계층에서는 여전히 문제가 존재 

**push**  
클라이언트가 따로 polling 할 필요 없이 서버가 새로운 데이터를 사용할 수 있을 때마다 클라이언트에 업데이트를 보낼 수 있음  

**이진 프로토콜**  
텍스트 기반 프로토콜이었기 때문에 정보가 아스키 코드로 저장
사람이 읽기에는 편하지만 불필요하게 데이터가 커지는 문제
이 데이터를 바이너리로 변환하여서 효율적으로 데이터를 전송할 수 있게 함  

**HPACK**  
달라진 부분만 다시 전송하는 허프만 코딩 기법을 사용
불필요하게 발생하는 오버헤드를 최소화

## HTTP/3 (2022)  
HTTP/3은 HTTP/1.1및 HTTP/2와 함계 WWW에서 정보를 교환하는데 사용되는 HTTP의 세번째 버전.UDP를 기반으로 개발됨
멀티 플렉싱을 가지고있고, 초기연결 시 지연시간 감소라는 장점있음. TCP사용하지 않기 때문에 3-way핸드셰이크없음
첫 연결 설정에 1-RTT만 소요된다. 클라이언트가 서버에 어떤 신호로 한번주고, 서버도 거기에 응답하기만 하면 바로 본통신 시작가능 

**QUIC**  
이는 UDP를 기반으로 개발됨
트랜스포트 계층에서 스트림을 일등 시민으로 간주
이 스트림들은 커넥션을 공유하고 있기 때문에, 새로운 스트림을 생성하기 위해 추가적인 handshake가 필요하지 않음
해당 스트림은 독립적으로 전송됨
즉, 한 스트림에 영향을 미치는 패킷 손실이, 다른 스트림에 영향을 미치지 않음
이를 통해 트랜스포트 계층에서의 HOL Blocking 문제 해결
인터넷 사용량이 많은 모바일 환경을 위해 설계되었음
TCP를 사용하면 한 네트워크에서 다른 네트워크로의 연결을 변경하는 handoff 가 느림
QUIC는 커넥션 ID라는 개념을 구현하여, IP 주소와 네트워크 인터페이스 간에 빠르게 커넥션을 전환할 수 있도록 함
이미 웹사이트의 25%에서 사용됨
AWS CloudFront, Nginx 등에서 HTTP/3 을 활성화시킬 수 있음 (NCP, SCP는 HTTP/2까지만 지원함)